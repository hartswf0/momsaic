<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#2c0b1e">
    <title>Wine Crush Saga</title>
    <style>
        :root {
            --bg-color: #2c0b1e;
            --dock-bg: #1a0510;
            --text-color: #fce4ec;
            --accent: #d81b60;
            --safe-top: env(safe-area-inset-top, 20px);
            --safe-bottom: env(safe-area-inset-bottom, 20px);
            --font-main: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        * { box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }
        
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: var(--bg-color);
            color: var(--text-color); font-family: var(--font-main);
            display: flex; flex-direction: column;
        }

        /* Layout */
        #game-container {
            position: relative; flex: 1; display: flex; flex-direction: column;
            justify-content: center; align-items: center; width: 100%; height: 100%;
        }

        canvas {
            display: block; width: 100%; height: 100%;
            object-fit: contain; z-index: 1;
        }

        /* HUD */
        #hud {
            position: absolute; top: var(--safe-top); left: 0; width: 100%;
            padding: 10px 20px; display: flex; justify-content: space-between;
            z-index: 10; pointer-events: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .hud-item {
            background: rgba(0,0,0,0.3); backdrop-filter: blur(4px);
            padding: 8px 16px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.1);
            font-size: 1.2rem; font-weight: bold;
        }

        /* Dock */
        #dock {
            position: absolute; bottom: 0; left: 0; width: 100%;
            padding: 10px 10px calc(10px + var(--safe-bottom)) 10px;
            background: linear-gradient(to top, var(--dock-bg), transparent);
            display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;
            z-index: 20; pointer-events: auto;
        }

        .dock-btn {
            background: rgba(255,255,255,0.1); border: none; color: white;
            padding: 10px 16px; border-radius: 12px; font-size: 0.9rem;
            cursor: pointer; backdrop-filter: blur(5px); transition: background 0.2s;
            display: flex; align-items: center; justify-content: center;
        }
        .dock-btn:active { background: var(--accent); transform: scale(0.95); }
        .dock-btn svg { width: 20px; height: 20px; pointer-events: none; }

        /* Overlays */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 11, 30, 0.9); backdrop-filter: blur(10px);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; transition: opacity 0.3s;
        }
        .overlay.hidden { opacity: 0; pointer-events: none; }

        h1 { font-size: 3rem; margin: 0 0 10px 0; background: linear-gradient(45deg, #ff80ab, #ffd180); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        h2 { font-size: 2rem; margin: 10px 0; color: #fff; }
        p { font-size: 1.1rem; color: #ddd; max-width: 80%; text-align: center; line-height: 1.5; }

        .big-btn {
            background: var(--accent); color: white; border: none;
            padding: 15px 40px; font-size: 1.5rem; font-weight: bold;
            border-radius: 50px; margin-top: 20px; cursor: pointer;
            box-shadow: 0 4px 15px rgba(216, 27, 96, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .big-btn:active { transform: scale(0.95); box-shadow: 0 2px 5px rgba(216, 27, 96, 0.4); }

        .stat-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 20px;
            margin: 20px 0; text-align: center;
        }
        .stat-box .label { font-size: 0.9rem; color: #aaa; text-transform: uppercase; letter-spacing: 1px; }
        .stat-box .value { font-size: 1.8rem; font-weight: bold; color: #fff; }

        /* Toast */
        #toast {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 3rem; font-weight: 900; color: #fff;
            text-shadow: 0 0 20px var(--accent), 2px 2px 0px #000;
            pointer-events: none; opacity: 0; z-index: 50;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            white-space: nowrap;
        }
        #toast.show { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="canvas"></canvas>

    <div id="hud">
        <div class="hud-item" id="score-display">0</div>
        <div class="hud-item" id="time-display">60</div>
    </div>

    <div id="toast"></div>

    <div id="overlay-intro" class="overlay">
        <h1>WINE CRUSH</h1>
        <p>Match 3 Merlots to survive the PTA meeting.<br>Swipes or taps accepted.</p>
        <button class="big-btn" id="btn-start">Start Tasting</button>
        <button class="dock-btn" id="btn-copy-prompt" style="margin-top:20px; background:transparent; opacity:0.6; font-size:0.8rem">Copy Seed Prompt</button>
    </div>

    <div id="overlay-results" class="overlay hidden">
        <h1>TIME'S UP!</h1>
        <div class="stat-grid">
            <div class="stat-box">
                <div class="label">Score</div>
                <div class="value" id="res-score">0</div>
            </div>
            <div class="stat-box">
                <div class="label">Best</div>
                <div class="value" id="res-best">0</div>
            </div>
            <div class="stat-box">
                <div class="label">Moves</div>
                <div class="value" id="res-moves">0</div>
            </div>
            <div class="stat-box">
                <div class="label">Best Combo</div>
                <div class="value" id="res-combo">0</div>
            </div>
        </div>
        <button class="big-btn" id="btn-restart">Another Round?</button>
    </div>

    <div id="dock">
        <button class="dock-btn" id="btn-reset" title="Restart">â†º</button>
        <button class="dock-btn" id="btn-hint" title="Hint">ðŸ’¡</button>
        <button class="dock-btn" id="btn-audio" title="Toggle Audio">ðŸ”Š</button>
        <button class="dock-btn" id="btn-motion" title="Reduce Motion">ðŸ’¨</button>
        <button class="dock-btn" id="btn-full" title="Fullscreen">â›¶</button>
    </div>
</div>

<script>
/**
 * WINE CRUSH SAGA - Single File Implementation
 * Pure JS, Canvas API, Web Audio API
 */

// --- CONFIGURATION ---
const COLS = 8;
const ROWS = 8;
const DURATION = 60;
const TILE_TYPES = 5;
const ANIM_SWAP = 250; // ms
const ANIM_FALL = 150; // ms per tile
const COLORS = [
    '#9C27B0', // Grape (Purple)
    '#E91E63', // Wine (Red)
    '#FFC107', // Cheese (Yellow)
    '#795548', // Cork (Brown)
    '#FF9800'  // Cracker (Orange)
];

// --- AUDIO SYSTEM (Tone.js inspired simplified synth) ---
class AudioSys {
    constructor() {
        this.ctx = null;
        this.enabled = true;
        this.masterGain = null;
    }

    init() {
        if (this.ctx) return;
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.3;
        this.masterGain.connect(this.ctx.destination);
    }

    toggle() {
        this.enabled = !this.enabled;
        if (!this.ctx && this.enabled) this.init();
        if (this.ctx) {
            if (this.ctx.state === 'suspended') this.ctx.resume();
            this.masterGain.gain.setTargetAtTime(this.enabled ? 0.3 : 0, this.ctx.currentTime, 0.1);
        }
        return this.enabled;
    }

    playTone(freq, type, dur, vol = 1.0) {
        if (!this.enabled || !this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(vol, this.ctx.currentTime + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
        
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + dur);
    }

    playSwap() { this.playTone(300, 'sine', 0.1, 0.5); }
    playInvalid() { this.playTone(150, 'sawtooth', 0.2, 0.5); }
    playMatch(combo) {
        const base = 440;
        const pentatonic = [0, 2, 4, 7, 9, 12]; // intervals
        const note = base * Math.pow(2, pentatonic[Math.min(combo, 5)] / 12);
        this.playTone(note, 'triangle', 0.3, 0.8);
        this.playTone(note * 1.5, 'sine', 0.4, 0.4); // Sparkle layer
    }
    playWin() {
        [0, 4, 7, 12].forEach((interval, i) => {
            setTimeout(() => {
                const note = 523.25 * Math.pow(2, interval/12);
                this.playTone(note, 'square', 0.4, 0.6);
            }, i * 100);
        });
    }
}

// --- GAME STATE ---
const State = { INTRO: 0, IDLE: 1, SELECTED: 2, SWAPPING: 3, MATCHING: 4, REFILLING: 5, OVER: 6 };
const audio = new AudioSys();
const storage = window.localStorage;

let canvas, ctx;
let width, height, scale;
let tileSize, gridOffsetX, gridOffsetY;

let grid = [];
let particles = [];
let anims = []; // Active animations

let state = State.INTRO;
let score = 0;
let time = DURATION;
let moves = 0;
let maxCombo = 0;
let lastTime = 0;
let selectedTile = null;
let reducedMotion = false;
let shakeTime = 0;

// Input tracking
let pointerDown = false;
let pointerStart = { x: 0, y: 0, r: -1, c: -1 };
let hoverTile = { r: -1, c: -1 };

// --- CORE FUNCTIONS ---

function init() {
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d', { alpha: false });
    
    // Listeners
    window.addEventListener('resize', resize);
    
    const inputHandler = (e) => {
        // Unify touch/mouse
        const type = e.type;
        const touch = e.touches ? e.touches[0] : e;
        if (!touch) return;
        
        const rect = canvas.getBoundingClientRect();
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;
        
        handleInput(type, x, y);
    };

    ['mousedown', 'mousemove', 'mouseup', 'touchstart', 'touchmove', 'touchend'].forEach(evt => {
        canvas.addEventListener(evt, (e) => {
            // Prevent scrolling on game board
            if (evt.startsWith('touch')) e.preventDefault();
            inputHandler(e);
        }, { passive: false });
    });

    // Dock
    document.getElementById('btn-start').onclick = startGame;
    document.getElementById('btn-restart').onclick = startGame;
    document.getElementById('btn-reset').onclick = startGame;
    document.getElementById('btn-hint').onclick = showHint;
    document.getElementById('btn-audio').onclick = () => {
        const on = audio.toggle();
        document.getElementById('btn-audio').innerText = on ? 'ðŸ”Š' : 'ðŸ”‡';
    };
    document.getElementById('btn-motion').onclick = () => {
        reducedMotion = !reducedMotion;
        document.getElementById('btn-motion').style.opacity = reducedMotion ? '0.5' : '1';
    };
    document.getElementById('btn-full').onclick = () => {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(e=>{});
        else document.exitFullscreen().catch(e=>{});
    };
    
    document.getElementById('btn-copy-prompt').onclick = () => {
        const p = "Generate a Match-3 game titled 'Wine Crush Saga'. Mobile-first, single HTML file. Theme: Wine, Cheese, Corks. Features: Audio toggle, Particles, Gravity, Score, Timer.";
        navigator.clipboard.writeText(p).then(() => showToast("Prompt Copied!"));
    };

    resize();
    requestAnimationFrame(loop);
}

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    scale = window.devicePixelRatio || 1;
    
    canvas.width = width * scale;
    canvas.height = height * scale;
    ctx.scale(scale, scale);
    
    // Calculate Grid dimensions
    const minDim = Math.min(width, height - 140); // Leave room for UI
    tileSize = Math.floor((minDim - 20) / COLS);
    
    // Center grid
    gridOffsetX = Math.floor((width - (tileSize * COLS)) / 2);
    gridOffsetY = Math.floor((height - (tileSize * ROWS)) / 2);
    
    // Update existing tile positions if resizing mid-game
    if (grid.length > 0) {
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                if (grid[r][c]) {
                    grid[r][c].x = c * tileSize + gridOffsetX;
                    grid[r][c].y = r * tileSize + gridOffsetY;
                    grid[r][c].ty = r * tileSize + gridOffsetY;
                }
            }
        }
    }
}

function createGrid() {
    grid = [];
    for(let r=0; r<ROWS; r++) {
        let row = [];
        for(let c=0; c<COLS; c++) {
            // Prevent initial matches
            let type;
            do {
                type = Math.floor(Math.random() * TILE_TYPES);
            } while (
                (c >= 2 && row[c-1].type === type && row[c-2].type === type) ||
                (r >= 2 && grid[r-1][c].type === type && grid[r-2][c].type === type)
            );
            
            row.push({
                r, c, type,
                x: c * tileSize + gridOffsetX,
                y: -tileSize * (ROWS - r), // Start above screen for drop-in
                ty: r * tileSize + gridOffsetY,
                scale: 1,
                alpha: 1,
                state: 'DROP'
            });
        }
        grid.push(row);
    }
}

function startGame() {
    if (state === State.INTRO) audio.init();
    
    score = 0;
    time = DURATION;
    moves = 0;
    maxCombo = 0;
    state = State.REFILLING; // Triggers drop-in
    selectedTile = null;
    particles = [];
    anims = [];
    
    document.getElementById('score-display').innerText = '0';
    document.getElementById('time-display').innerText = time;
    document.getElementById('overlay-intro').classList.add('hidden');
    document.getElementById('overlay-results').classList.add('hidden');
    
    createGrid();
    
    // Animate initial drop
    grid.forEach(row => row.forEach(t => {
        t.y = t.ty; // Snap to position for simplicity or animate
        t.state = 'IDLE';
    }));
    
    state = State.IDLE;
    
    // Start timer
    if (window.gameTimer) clearInterval(window.gameTimer);
    window.gameTimer = setInterval(() => {
        if (state !== State.OVER && state !== State.INTRO) {
            time--;
            document.getElementById('time-display').innerText = time;
            if (time <= 0) endGame();
        }
    }, 1000);
}

function endGame() {
    state = State.OVER;
    clearInterval(window.gameTimer);
    
    const best = parseInt(storage.getItem('wine_best') || '0');
    if (score > best) storage.setItem('wine_best', score);
    
    document.getElementById('res-score').innerText = score;
    document.getElementById('res-best').innerText = Math.max(score, best);
    document.getElementById('res-moves').innerText = moves;
    document.getElementById('res-combo').innerText = maxCombo;
    document.getElementById('overlay-results').classList.remove('hidden');
    
    audio.playWin();
}

// --- LOGIC ---

function getTileAt(x, y) {
    if (x < gridOffsetX || x > gridOffsetX + COLS * tileSize ||
        y < gridOffsetY || y > gridOffsetY + ROWS * tileSize) return null;
    
    const c = Math.floor((x - gridOffsetX) / tileSize);
    const r = Math.floor((y - gridOffsetY) / tileSize);
    if (r >=0 && r < ROWS && c >= 0 && c < COLS) return grid[r][c];
    return null;
}

function handleInput(type, x, y) {
    if (state !== State.IDLE && state !== State.SELECTED) return;

    if (type === 'mousedown' || type === 'touchstart') {
        pointerDown = true;
        const t = getTileAt(x, y);
        if (t) {
            pointerStart = { x, y, r: t.r, c: t.c };
            // Tap selection logic
            if (state === State.IDLE) {
                selectedTile = t;
                state = State.SELECTED;
                audio.playTone(800, 'sine', 0.05, 0.2); // Select click
            } else if (state === State.SELECTED) {
                if (t === selectedTile) {
                    selectedTile = null; // Deselect
                    state = State.IDLE;
                } else if (isAdjacent(t, selectedTile)) {
                    attemptSwap(selectedTile, t);
                } else {
                    selectedTile = t; // Change selection
                    audio.playTone(800, 'sine', 0.05, 0.2);
                }
            }
        }
    } else if (type === 'mousemove' || type === 'touchmove') {
        const t = getTileAt(x, y);
        if (t) hoverTile = { r: t.r, c: t.c };
        
        // Drag logic
        if (pointerDown && state === State.SELECTED && selectedTile) {
            const dx = x - pointerStart.x;
            const dy = y - pointerStart.y;
            if (Math.abs(dx) > tileSize/2 || Math.abs(dy) > tileSize/2) {
                // Dragged far enough
                let r2 = selectedTile.r;
                let c2 = selectedTile.c;
                if (Math.abs(dx) > Math.abs(dy)) c2 += Math.sign(dx);
                else r2 += Math.sign(dy);
                
                if (r2 >= 0 && r2 < ROWS && c2 >= 0 && c2 < COLS) {
                    attemptSwap(selectedTile, grid[r2][c2]);
                    pointerDown = false; // Stop drag
                }
            }
        }
    } else if (type === 'mouseup' || type === 'touchend') {
        pointerDown = false;
    }
}

function isAdjacent(t1, t2) {
    return Math.abs(t1.r - t2.r) + Math.abs(t1.c - t2.c) === 1;
}

function attemptSwap(t1, t2) {
    state = State.SWAPPING;
    selectedTile = null;
    moves++;
    
    // Visual swap
    animateSwap(t1, t2, () => {
        // Logic swap
        const tempType = t1.type;
        t1.type = t2.type;
        t2.type = tempType;
        
        const matches = findMatches();
        if (matches.length > 0) {
            processMatches(matches);
        } else {
            // Invalid swap, swap back
            audio.playInvalid();
            animateSwap(t1, t2, () => {
                const temp = t1.type;
                t1.type = t2.type;
                t2.type = temp;
                state = State.IDLE;
            });
        }
    });
}

function animateSwap(t1, t2, callback) {
    audio.playSwap();
    const duration = reducedMotion ? 100 : ANIM_SWAP;
    const start = performance.now();
    const sx1 = t1.x, sy1 = t1.y, sx2 = t2.x, sy2 = t2.y;
    
    anims.push({
        update: (now) => {
            const p = Math.min((now - start) / duration, 1);
            // Ease in-out
            const ease = p < .5 ? 2 * p * p : -1 + (4 - 2 * p) * p;
            
            t1.x = sx1 + (sx2 - sx1) * ease;
            t1.y = sy1 + (sy2 - sy1) * ease;
            t2.x = sx2 + (sx1 - sx2) * ease;
            t2.y = sy2 + (sy1 - sy2) * ease;
            
            if (p >= 1) {
                // Fix positions
                t1.x = sx2; t1.y = sy2;
                t2.x = sx1; t2.y = sy1;
                return false; // Remove anim
            }
            return true;
        },
        onComplete: callback
    });
}

function findMatches() {
    let matched = new Set();
    
    // Horizontal
    for(let r=0; r<ROWS; r+
