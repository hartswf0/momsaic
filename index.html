<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MOMSAIC</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ§©</text></svg>">
    <style>
        :root {
            --bg: #0a0a0a;
            --surface: #141414;
            --accent: #fff;
            --dim: #888;
            --highlight: #00e5ff;
            --dock-bg: rgba(20, 20, 20, 0.95);
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            margin: 0; padding: 0;
        }

        body {
            background-color: var(--bg);
            color: var(--accent);
            font-family: 'Segoe UI', system-ui, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* --- Icons --- */
        .icon {
            width: 24px; height: 24px;
            fill: none; stroke: currentColor;
            stroke-width: 2; stroke-linecap: round; stroke-linejoin: round;
        }

        /* --- Game Stage --- */
        #stage {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%; height: 100%;
            position: relative;
            padding-bottom: 90px;
            transition: padding 0.3s;
        }

        canvas {
            box-shadow: 0 10px 50px rgba(0,0,0,0.8);
            touch-action: none;
            max-width: 95%; max-height: 95%;
            border-radius: 4px;
            transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .stage-win canvas {
            transform: scale(0.9);
            box-shadow: 0 0 100px var(--highlight);
        }

        /* --- HUD --- */
        header {
            position: absolute; top: 0; left: 0; right: 0;
            padding: 20px;
            display: flex; justify-content: space-between;
            pointer-events: none; z-index: 10;
        }

        .hud-item {
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            padding: 8px 16px;
            border-radius: 20px;
            font-variant-numeric: tabular-nums;
            font-weight: 600;
            pointer-events: auto;
            border: 1px solid rgba(255,255,255,0.1);
            font-size: 0.9rem;
            display: flex; align-items: center; gap: 8px;
        }

        /* --- Dock --- */
        .dock-container {
            position: absolute; bottom: 30px; left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            display: flex; flex-direction: column; align-items: center;
            gap: 12px;
        }

        .dock {
            display: flex; gap: 12px;
            background: var(--dock-bg);
            padding: 12px 20px;
            border-radius: 24px;
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(15px);
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .dock.collapsed {
            transform: scale(0.8) translateY(20px);
            opacity: 0; pointer-events: none;
        }

        .dock-toggle {
            background: var(--dock-bg);
            border: 1px solid rgba(255,255,255,0.1);
            color: var(--accent);
            width: 36px; height: 36px;
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
            backdrop-filter: blur(15px);
            transition: transform 0.3s;
        }
        
        .dock-container.closed .dock-toggle { transform: rotate(180deg); }

        .btn {
            background: transparent; border: none;
            color: var(--dim); cursor: pointer;
            transition: all 0.2s;
            display: flex; align-items: center; justify-content: center;
            width: 48px; height: 48px;
            border-radius: 12px;
        }

        .btn:hover { color: var(--accent); background: rgba(255,255,255,0.08); }
        .btn:active { transform: scale(0.92); }
        .btn.active { color: var(--highlight); background: rgba(0, 229, 255, 0.1); stroke: var(--highlight); }
        .btn.shimmer { animation: pulse-border 2s infinite; color: var(--highlight); }

        @keyframes pulse-border {
            0% { box-shadow: 0 0 0 0 rgba(0, 229, 255, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(0, 229, 255, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 229, 255, 0); }
        }

        input[type="file"] { display: none; }

        /* --- Overlays --- */
        .overlay {
            position: absolute; inset: 0;
            background: rgba(0,0,0,0.95);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 100;
            transition: opacity 0.4s, visibility 0.4s;
            opacity: 0; visibility: hidden;
        }
        .overlay.visible { opacity: 1; visibility: visible; }

        .intro-title {
            font-size: 4rem; font-weight: 200;
            letter-spacing: 12px;
            background: linear-gradient(to right, #fff, #888);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px; text-align: center;
        }
        .intro-sub { opacity: 0.5; letter-spacing: 2px; margin-bottom: 20px; font-size: 0.9rem; }
        
        #loading-log {
            font-family: monospace;
            color: var(--highlight);
            height: 20px;
            margin-bottom: 30px;
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .big-btn {
            background: #fff; color: #000; border: none;
            padding: 18px 40px;
            font-size: 1.1rem; font-weight: 600;
            letter-spacing: 1px; cursor: pointer;
            text-transform: uppercase; border-radius: 4px;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 8px; min-width: 220px;
        }
        .big-btn:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(255,255,255,0.2); }
        .big-btn.secondary { background: transparent; color: #fff; border: 1px solid #333; }
        .big-btn.secondary:hover { border-color: #fff; }

        /* --- Grid Selector Modal --- */
        #grid-modal {
            background: rgba(20,20,20,0.98);
            border: 1px solid #333;
            border-radius: 16px;
            padding: 20px; text-align: center; z-index: 200;
            width: 90%; max-width: 300px;
            max-height: 80vh; overflow-y: auto;
        }
        .grid-options-container {
            display: grid; grid-template-columns: 1fr 1fr; gap: 8px;
            margin-bottom: 15px;
        }
        .grid-option {
            padding: 12px; background: #111; border: 1px solid #333;
            color: #fff; font-size: 0.9rem; cursor: pointer; border-radius: 8px;
            transition: all 0.2s;
        }
        .grid-option:hover { background: #222; border-color: #fff; }
        .grid-option.active { background: #fff; color: #000; border-color: #fff; }

        /* --- Hint Overlay --- */
        #hint-overlay {
            position: absolute; inset: 0; background: #000;
            z-index: 50; opacity: 0; pointer-events: none;
            transition: opacity 0.5s ease;
            display: flex; justify-content: center; align-items: center;
        }
        #hint-overlay img { max-width: 95%; max-height: 95%; box-shadow: 0 0 50px rgba(255,255,255,0.2); }
        #hint-overlay.visible { opacity: 1; }

        /* --- Parody Ad Styles --- */
        #ad-overlay { background: rgba(0,0,0,0.98); z-index: 300; }
        .ad-card {
            background: #fff; color: #000;
            width: 90%; max-width: 360px;
            border-radius: 16px; overflow: hidden;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8);
            animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-align: center; position: relative;
        }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        .ad-canvas-container { width: 100%; height: 200px; background: #000; position: relative; }
        .ad-canvas-container canvas { width: 100%; height: 100%; }
        
        .ad-badge {
            position: absolute; top: 10px; left: 10px;
            background: #fcbf49; color: #000;
            font-size: 0.7rem; font-weight: 800;
            padding: 4px 8px; border-radius: 4px;
            text-transform: uppercase;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .ad-content { padding: 25px; }
        .ad-title { font-size: 1.6rem; font-weight: 900; margin-bottom: 5px; line-height: 1; color: #111; }
        .ad-desc { font-size: 0.95rem; color: #555; margin-bottom: 25px; line-height: 1.4; }
        
        .ad-btn {
            background: #2563eb; color: #fff;
            border: none; padding: 14px 0; width: 100%;
            border-radius: 12px;
            font-weight: 800; font-size: 1.1rem;
            cursor: pointer;
            box-shadow: 0 4px 0 #1d4ed8;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .ad-btn:active { transform: translateY(4px); box-shadow: 0 0 0 #1d4ed8; }

        .ad-close {
            position: absolute; top: 10px; right: 10px;
            background: rgba(0,0,0,0.5); color: #fff;
            width: 32px; height: 32px;
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; cursor: pointer;
            opacity: 0; pointer-events: none;
            transition: opacity 0.3s;
            font-family: sans-serif;
            z-index: 10;
        }
        .ad-close.visible { opacity: 1; pointer-events: auto; }

        /* Gallery Overlay */
        #gallery-overlay { background: #111; transform: translateY(100%); transition: transform 0.3s ease; display: flex; flex-direction: column; z-index: 250; }
        #gallery-overlay.visible { transform: translateY(0); opacity: 1; visibility: visible; }
        
        .gallery-header {
            padding: 20px; background: #1a1a1a;
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid #333;
        }
        .gallery-grid {
            flex: 1; padding: 20px; overflow-y: auto;
            display: grid; grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
            gap: 10px;
        }
        .gallery-item {
            aspect-ratio: 1; background: #222; border-radius: 8px; overflow: hidden;
            position: relative; border: 1px solid #333;
        }
        .gallery-item img { width: 100%; height: 100%; object-fit: cover; }
        .gallery-badge {
            position: absolute; bottom: 0; left: 0; right: 0;
            background: rgba(0,0,0,0.7); color: #fff;
            font-size: 0.7rem; padding: 4px; text-align: center;
        }
        
        /* Toast */
        #toast {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 229, 255, 0.9); color: #000;
            padding: 10px 20px; border-radius: 20px; font-weight: bold;
            opacity: 0; transition: opacity 0.3s, transform 0.3s;
            pointer-events: none; z-index: 1000;
            width: max-content;
        }
        #toast.show { opacity: 1; transform: translateX(-50%) translateY(10px); }

        /* Mosaic Loader for Intro */
        .mosaic-loader {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
            width: 60px; height: 60px;
            margin-bottom: 20px;
        }
        .m-tile {
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            animation: pulse-tile 1.5s infinite;
        }
        @keyframes pulse-tile {
            0%, 100% { background: rgba(255,255,255,0.1); }
            50% { background: var(--highlight); box-shadow: 0 0 10px var(--highlight); }
        }

    </style>
</head>
<body>

<header>
    <div class="hud-item" id="counter">Moves: 0</div>
    <div class="hud-item" id="radio-status">
        <svg class="icon" viewBox="0 0 24 24"><path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle></svg>
        <span>OFF</span>
    </div>
</header>

<div id="toast"></div>

<!-- The Game Stage -->
<div id="stage">
    <canvas id="cvs"></canvas>
    <div id="hint-overlay"><img id="hint-img"></div>
</div>

<!-- Intro -->
<div id="intro" class="overlay visible">
    <div class="intro-title">MOMSAIC</div>
    <div class="intro-sub">RELAX & RESTORE</div>
    
    <div class="mosaic-loader" id="intro-loader">
        <!-- JS fills this -->
    </div>
    
    <div id="loading-log">Initializing Vibes...</div>
    
    <div id="intro-buttons" style="opacity: 0; transition: opacity 1s;">
        <button class="big-btn" onclick="game.startDefault()">Play Art</button>
        <button class="big-btn secondary" onclick="document.getElementById('upl').click()">Load Photo</button>
        <button class="big-btn secondary" onclick="gallery.show()">Gallery</button>
    </div>
</div>

<!-- Grid Selector Modal -->
<div id="grid-selector" class="overlay" style="background: rgba(0,0,0,0.8);">
    <div id="grid-modal">
        <h2 style="margin-bottom: 20px;">Grid Size</h2>
        <div class="grid-options-container">
            <button class="grid-option" onclick="game.setGrid(3)">3 x 3</button>
            <button class="grid-option" onclick="game.setGrid(4)">4 x 4</button>
            <button class="grid-option" onclick="game.setGrid(5)">5 x 5</button>
            <button class="grid-option" onclick="game.setGrid(6)">6 x 6</button>
            <button class="grid-option" onclick="game.setGrid(7)">7 x 7</button>
            <button class="grid-option" onclick="game.setGrid(8)">8 x 8</button>
            <button class="grid-option" onclick="game.setGrid(9)" style="grid-column: 1 / -1; border-color: var(--highlight); color: var(--highlight);">9 x 9 (Master)</button>
        </div>
        <button class="big-btn secondary" style="margin-top:10px; width:100%;" onclick="document.getElementById('grid-selector').classList.remove('visible')">Cancel</button>
    </div>
</div>

<!-- Dock -->
<div class="dock-container" id="dock-container">
    <div class="dock" id="dock-bar">
        <!-- Shuffle -->
        <button class="btn shimmer" onclick="game.shuffle()" title="Shuffle / Start">
            <svg class="icon" viewBox="0 0 24 24"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/></svg>
        </button>
        <!-- Grid -->
        <button class="btn" onclick="document.getElementById('grid-selector').classList.add('visible')" title="Grid Size">
            <svg class="icon" viewBox="0 0 24 24"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/></svg>
        </button>
        <!-- Hint (Peek) -->
        <button class="btn" id="hint-btn" title="Peek" onmousedown="game.showHint()" onmouseup="game.hideHint()" ontouchstart="game.showHint()" ontouchend="game.hideHint()">
            <svg class="icon" viewBox="0 0 24 24"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
        </button>
        <!-- Photo -->
        <button class="btn" onclick="document.getElementById('upl').click()" title="New Photo">
            <svg class="icon" viewBox="0 0 24 24"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>
        </button>
        <!-- Radio -->
        <button class="btn" id="radio-btn" onclick="synth.toggle()" title="Lofi Radio">
            <svg class="icon" viewBox="0 0 24 24"><path d="M9 18V5l12-2v13"/><circle cx="6" cy="18" r="3"/><circle cx="18" cy="16" r="3"/></svg>
        </button>
        <!-- Fullscreen -->
        <button class="btn" onclick="game.toggleFullscreen()" title="Fullscreen">
            <svg class="icon" viewBox="0 0 24 24"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
        </button>
        <!-- Gallery -->
        <button class="btn" onclick="gallery.show()" title="Gallery">
            <svg class="icon" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>
        </button>
        <input type="file" id="upl" accept="image/*">
    </div>
    <button class="dock-toggle" onclick="ui.toggleDock()">
        <svg class="icon" style="width:16px;height:16px;" viewBox="0 0 24 24"><polyline points="6 9 12 15 18 9"/></svg>
    </button>
</div>

<!-- Win -->
<div id="win" class="overlay">
    <h1 style="font-size:3rem; margin-bottom:10px; text-align:center;">MASTERPIECE</h1>
    <p style="margin-bottom:40px; letter-spacing:1px; opacity:0.7;">IMAGE RESTORED</p>
    <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:center;">
        <button class="big-btn" onclick="game.next()">Next Level</button>
    </div>
</div>

<!-- Gallery -->
<div id="gallery-overlay" class="overlay">
    <div class="gallery-header">
        <span style="font-weight:bold; letter-spacing:1px;">MY COLLECTION</span>
        <button class="btn" onclick="gallery.hide()">
            <svg class="icon" viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
        </button>
    </div>
    <div class="gallery-grid" id="gallery-grid"></div>
</div>

<!-- Ad -->
<div id="ad-overlay" class="overlay">
    <div class="ad-card">
        <div class="ad-badge">ADVERTISEMENT</div>
        <div class="ad-close" id="ad-close-btn" onclick="ads.close(true)">âœ•</div>
        <div class="ad-canvas-container">
            <canvas id="ad-canvas"></canvas>
        </div>
        <div class="ad-content">
            <div id="ad-title" class="ad-title">Game Title</div>
            <div id="ad-desc" class="ad-desc">Game Description</div>
            <button class="ad-btn" onclick="ads.click()">GENERATE THIS GAME</button>
        </div>
    </div>
</div>

<script>
    // --- Robust Copy Utils ---
    async function copyText(text) {
        // Try Native Clipboard
        try {
            await navigator.clipboard.writeText(text);
            return true;
        } catch (err) {
            // Fallback: Textarea hack
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed"; 
            textArea.style.left = "-9999px"; 
            textArea.style.top = "0";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                const successful = document.execCommand('copy');
                document.body.removeChild(textArea);
                return successful;
            } catch (err) {
                document.body.removeChild(textArea);
                return false;
            }
        }
    }

    // --- Procedural Lofi Synthesizer ---
    class LofiSynth {
        constructor() {
            this.ctx = null;
            this.isPlaying = false;
            this.nextNoteTime = 0;
            this.beatCount = 0;
            this.tempo = 80;
            this.timerID = null;
        }

        init() {
            if(!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            if(this.ctx.state === 'suspended') this.ctx.resume();
        }

        toggle() {
            this.init();
            if(this.isPlaying) this.stop();
            else this.start();
            this.updateUI();
        }

        start() {
            this.isPlaying = true;
            this.nextNoteTime = this.ctx.currentTime;
            this.beatCount = 0;
            this.scheduler();
        }

        stop() {
            this.isPlaying = false;
            clearTimeout(this.timerID);
        }

        updateUI() {
            const el = document.getElementById('radio-status').querySelector('span');
            const btn = document.getElementById('radio-btn');
            if(this.isPlaying) {
                el.innerText = "LOFI";
                btn.classList.add('active');
            } else {
                el.innerText = "OFF";
                btn.classList.remove('active');
            }
        }

        scheduler() {
            if(!this.isPlaying) return;
            while(this.nextNoteTime < this.ctx.currentTime + 0.1) {
                this.playBeat(this.nextNoteTime, this.beatCount);
                this.scheduleChord(this.nextNoteTime, this.beatCount);
                this.nextNoteTime += 60.0 / this.tempo;
                this.beatCount++;
            }
            this.timerID = setTimeout(() => this.scheduler(), 25);
        }

        playBeat(time, beat) {
            if(beat % 4 === 0 || (beat % 8 === 4 && Math.random() > 0.5)) this.kick(time);
            if(beat % 4 === 2) this.snare(time);
            if(beat % 1 === 0) this.hihat(time, Math.random()*0.5 + 0.5);
        }

        kick(time) {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.frequency.setValueAtTime(150, time);
            osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
            gain.gain.setValueAtTime(0.5, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
            osc.start(time); osc.stop(time + 0.5);
        }

        snare(time) {
            const noise = this.ctx.createBufferSource();
            const buffer = this.ctx.createBuffer(1, 44100 * 0.2, 44100);
            const data = buffer.getChannelData(0);
            for(let i=0; i<data.length; i++) data[i] = (Math.random()*2-1);
            noise.buffer = buffer;
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'highpass'; filter.frequency.value = 1000;
            noise.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
            gain.gain.setValueAtTime(0.3, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
            noise.start(time);
        }

        hihat(time, vol) {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'square';
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'highpass'; filter.frequency.value = 8000;
            osc.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
            gain.gain.setValueAtTime(vol * 0.05, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
            osc.start(time); osc.stop(time+0.05);
        }

        scheduleChord(time, beat) {
            if(beat % 8 === 0) {
                const freqs = Math.random() > 0.5 ? [130.81, 155.56, 196.00, 233.08] : [174.61, 207.65, 261.63, 311.13];
                freqs.forEach(f => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'triangle';
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass'; filter.frequency.value = 800 + Math.random()*500;
                    osc.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
                    osc.frequency.value = f;
                    gain.gain.setValueAtTime(0, time);
                    gain.gain.linearRampToValueAtTime(0.05, time + 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.001, time + 4);
                    osc.start(time); osc.stop(time+4);
                });
            }
        }
        
        playWin() {
            this.init();
            const t = this.ctx.currentTime;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.frequency.setValueAtTime(200, t);
            osc.frequency.exponentialRampToValueAtTime(800, t+0.5);
            gain.gain.setValueAtTime(0.2, t);
            gain.gain.linearRampToValueAtTime(0, t+0.5);
            osc.start(t); osc.stop(t+0.5);
        }
        
        playSnap() {
            this.init();
            const t = this.ctx.currentTime;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'sine';
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.frequency.setValueAtTime(880, t);
            gain.gain.setValueAtTime(0.1, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t+0.1);
            osc.start(t); osc.stop(t+0.1);
        }
        
        playSwap() {
            this.init();
            const t = this.ctx.currentTime;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(300, t);
            gain.gain.setValueAtTime(0.05, t);
            gain.gain.linearRampToValueAtTime(0, t+0.1);
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(t); osc.stop(t+0.1);
        }
    }

    const synth = new LofiSynth();

    // --- Particle System ---
    class Particle {
        constructor(w, h) {
            this.x = w/2; this.y = h/2;
            this.vx = (Math.random()-0.5) * 20;
            this.vy = (Math.random()-0.5) * 20;
            this.color = `hsl(${Math.random()*360}, 100%, 60%)`;
            this.life = 1.0;
            this.size = Math.random() * 8 + 4;
        }
        update() {
            this.x += this.vx; this.y += this.vy;
            this.vy += 0.5; this.life -= 0.015;
        }
        draw(ctx) {
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.size, this.size);
            ctx.globalAlpha = 1.0;
        }
    }

    // --- Fake Ads ---
    const adData = [
        { 
            t: "Wine Crush Saga", d: "Match 3 Merlots to survive the PTA meeting!", 
            c: "#720e1e", type: "match3", 
            p: "Create a single-file HTML match-3 game called 'Wine Crush'. Theme: Wine glasses, cheese, grapes. Features: Score counter, particle effects on match, 'Cheers' sound effect (synth), 1-minute timer.",
            speak: "Are you ready to crush some grapes? Play Wine Crush Saga now."
        },
        { 
            t: "Laundry Legend", d: "Can YOU fold a fitted sheet? 99% of Moms FAIL level 1.", 
            c: "#3b82f6", type: "fold",
            p: "Create a single-file HTML physics game called 'Laundry Legend'. Objective: Stack folded clothes (rectangles) as high as possible without them toppling. Include a 'Fitted Sheet' boss level that creates wobbly physics.",
            speak: "Bet you can't fold this sheet. Be a Laundry Legend."
        },
        { 
            t: "Quiet Place: Mom Ed.", d: "Objective: Eat a snack without the kids hearing.", 
            c: "#111", type: "stealth",
            p: "Create a single-file HTML stealth game called 'Quiet Snacker'. Gameplay: Hold mouse button to open chip bag. A 'Noise Meter' fills up. Release to stop. If meter hits red, 'MOM!' text appears and game over.",
            speak: "Shhh. They can hear the crinkle. Play Quiet Place Mom Edition."
        },
        {
            t: "Tupperware Tetris", d: "Find the matching lid before the cabinet explodes!",
            c: "#e11d48", type: "tetris",
            p: "Create a single-file HTML Tetris clone called 'Tupperware Tetris'. Blocks are plastic containers of different colors. You must match container color to lid color to clear lines. Chaotic cabinet background.",
            speak: "Where is the lid? Play Tupperware Tetris."
        },
        {
            t: "Coupon Ninja", d: "Slice 50% Off before it expires!",
            c: "#16a34a", type: "ninja",
            p: "Create a single-file HTML game called 'Coupon Ninja'. Gameplay: 'Coupons' fly up from bottom. Slice them with mouse drag. Avoid slicing 'Credit Cards'. Score tracks money saved.",
            speak: "Slice the prices. Save the day. Play Coupon Ninja."
        }
    ];
    
    let adInterval = null;
    let currentAd = null;

    const ads = {
        show: () => {
            currentAd = adData[Math.floor(Math.random()*adData.length)];
            const c = document.getElementById('ad-canvas');
            c.width = 300; c.height = 200;
            const ctx = c.getContext('2d');
            
            document.getElementById('ad-title').innerText = currentAd.t;
            document.getElementById('ad-desc').innerText = currentAd.d;
            document.getElementById('ad-overlay').classList.add('visible');
            
            // TTS
            if ('speechSynthesis' in window) {
                const u = new SpeechSynthesisUtterance(currentAd.speak);
                u.rate = 1.1; u.pitch = 1.2;
                window.speechSynthesis.speak(u);
            }
            
            // Close Timer
            const closeBtn = document.getElementById('ad-close-btn');
            closeBtn.classList.remove('visible');
            closeBtn.innerText = "3";
            let cd = 3;
            const cdInt = setInterval(() => {
                cd--;
                if(cd <= 0) {
                    clearInterval(cdInt);
                    closeBtn.innerText = "âœ•";
                    closeBtn.classList.add('visible');
                } else {
                    closeBtn.innerText = cd;
                }
            }, 1000);

            // Animate Fake Game
            let f = 0;
            if(adInterval) clearInterval(adInterval);
            adInterval = setInterval(() => {
                f++;
                ctx.fillStyle = currentAd.c; ctx.fillRect(0,0,300,200);
                if(currentAd.type === 'match3') {
                    for(let i=0; i<5; i++) {
                        ctx.fillStyle = `hsl(${(f*5 + i*50)%360}, 70%, 50%)`;
                        ctx.beginPath(); ctx.arc(50 + i*50, 100 + Math.sin(f*0.1 + i)*20, 15, 0, Math.PI*2); ctx.fill();
                    }
                } else if(currentAd.type === 'fold') {
                    ctx.fillStyle = "#fff"; ctx.translate(150, 100); ctx.rotate(f*0.05);
                    ctx.fillRect(-40, -40, 80, 80); ctx.setTransform(1,0,0,1,0,0);
                } else {
                    ctx.fillStyle = "#fff"; ctx.font = "20px monospace"; ctx.fillText("GAMEPLAY", 100, 100 + Math.random()*5);
                }
            }, 50);
        },
        close: (force=false) => {
            // Force close allows button to work
            if(!force && !document.getElementById('ad-close-btn').classList.contains('visible')) return;
            
            clearInterval(adInterval);
            document.getElementById('ad-overlay').classList.remove('visible');
            setTimeout(() => game.init(false), 300); 
        },
        click: () => {
            // Copy One-Shot Prompt using Robust Fallback
            copyText(currentAd.p).then((success) => {
                if(success) {
                    ui.toast("PROMPT COPIED! Paste in AI to play.");
                    setTimeout(() => ads.close(true), 1500);
                } else {
                    ui.toast("Copy failed. Try manually.");
                }
            });
        }
    };

    // --- Gallery ---
    const gallery = {
        save: (img, moves) => {
            const saves = JSON.parse(localStorage.getItem('momsaic_saves') || "[]");
            saves.unshift({i:img, m:moves});
            if(saves.length > 20) saves.pop();
            localStorage.setItem('momsaic_saves', JSON.stringify(saves));
        },
        show: () => {
            const el = document.getElementById('gallery-grid');
            el.innerHTML = "";
            const saves = JSON.parse(localStorage.getItem('momsaic_saves') || "[]");
            saves.forEach(s => {
                const d = document.createElement('div');
                d.className = 'gallery-item';
                d.innerHTML = `<img src="${s.i}"><div class="gallery-badge">${s.m} moves</div>`;
                el.appendChild(d);
            });
            document.getElementById('gallery-overlay').classList.add('visible');
        },
        hide: () => { document.getElementById('gallery-overlay').classList.remove('visible'); }
    };

    const ui = {
        toggleDock: () => {
            const d = document.getElementById('dock-bar');
            const c = document.getElementById('dock-container');
            const s = document.getElementById('stage');
            if(d.classList.contains('collapsed')) {
                d.classList.remove('collapsed'); c.classList.remove('closed'); s.style.paddingBottom = "90px";
            } else {
                d.classList.add('collapsed'); c.classList.add('closed'); s.style.paddingBottom = "20px";
            }
        },
        toast: (msg) => {
            const t = document.getElementById('toast');
            t.innerText = msg; t.classList.add('show');
            setTimeout(()=>t.classList.remove('show'), 2500);
        }
    };

    // --- Game Logic ---
    class Momsaic {
        constructor() {
            this.c = document.getElementById('cvs');
            this.ctx = this.c.getContext('2d');
            this.img = new Image();
            this.tiles = [];
            this.particles = [];
            
            this.rows = 3; this.cols = 3; 
            this.moves = 0; 
            this.loaded = false;
            this.isPlaying = false;
            
            this.activeTile = null; this.hoverTile = null;
            this.w = 0; this.h = 0;

            const start = (x,y) => this.down(x,y);
            const move = (x,y) => this.move(x,y);
            const end = () => this.up();

            this.c.addEventListener('mousedown', e => start(e.clientX, e.clientY));
            window.addEventListener('mousemove', e => move(e.clientX, e.clientY));
            window.addEventListener('mouseup', end);
            this.c.addEventListener('touchstart', e => { e.preventDefault(); start(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
            window.addEventListener('touchmove', e => { e.preventDefault(); move(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
            window.addEventListener('touchend', end);
            window.addEventListener('resize', () => this.resize());
            document.getElementById('upl').addEventListener('change', e => this.upload(e));
            
            this.introSequence();
            requestAnimationFrame(() => this.loop());
        }
        
        introSequence() {
            // Mosaic loading animation
            const loader = document.getElementById('intro-loader');
            loader.innerHTML = '';
            for(let i=0; i<16; i++) {
                const div = document.createElement('div');
                div.className = 'm-tile';
                div.style.animationDelay = `${Math.random()*1}s`;
                loader.appendChild(div);
            }

            const log = document.getElementById('loading-log');
            const msgs = [
                "Initializing Vibes...", 
                "Decanting Pixels...", 
                "Hiding Vegetables...", 
                "Locating Reading Glasses...", 
                "Calibrating Wine Levels...",
                "Sorting Tupperware...",
                "Mom-OS v5.0 Ready."
            ];
            let i = 0;
            const iv = setInterval(() => {
                log.innerText = msgs[i];
                i++;
                if(i >= msgs.length) {
                    clearInterval(iv);
                    document.getElementById('intro-buttons').style.opacity = 1;
                }
            }, 500);
        }

        startDefault() { this.genArt(); }
        
        upload(e) {
            const f = e.target.files[0];
            if(!f) return;
            const r = new FileReader();
            r.onload = evt => { this.img.src = evt.target.result; this.img.onload = () => this.init(true); };
            r.readAsDataURL(f);
        }

        genArt() {
            const c = document.createElement('canvas'); c.width = 800; c.height = 1000;
            const x = c.getContext('2d');
            const g = x.createLinearGradient(0,0,0,1000); g.addColorStop(0,"#111"); g.addColorStop(1,"#000");
            x.fillStyle = g; x.fillRect(0,0,800,1000);
            for(let i=0; i<40; i++) {
                x.fillStyle = `hsl(${Math.random()*360}, 70%, 60%)`;
                x.beginPath(); x.arc(Math.random()*800, Math.random()*1000, Math.random()*100, 0, Math.PI*2); x.fill();
            }
            this.img.src = c.toDataURL();
            this.img.onload = () => this.init(true);
        }

        init(reset=false) {
            document.getElementById('intro').classList.remove('visible');
            document.getElementById('win').classList.remove('visible');
            document.getElementById('stage').classList.remove('stage-win');
            
            this.loaded = true;
            this.isPlaying = false; 
            this.moves = 0;
            document.getElementById('counter').innerText = `Moves: 0`;
            document.getElementById('hint-img').src = this.img.src;
            
            this.resize();
            this.makeTiles(); 
            synth.init();
        }

        setGrid(size) {
            this.rows = size;
            this.cols = size; // Default square logic, adjusted in resize
            document.getElementById('grid-selector').classList.remove('visible');
            this.init(); 
        }

        shuffle() {
            if(!this.loaded) return;
            const pos = this.tiles.map(t=>({r:t.r, c:t.c}));
            for(let i=pos.length-1; i>0; i--) {
                const j = Math.floor(Math.random()*(i+1));
                [pos[i], pos[j]] = [pos[j], pos[i]];
            }
            this.tiles.forEach((t, i) => {
                t.r = pos[i].r; t.c = pos[i].c;
                t.currX = t.c * this.w; t.currY = t.r * this.h;
            });
            this.isPlaying = true;
            this.moves = 0;
            document.getElementById('counter').innerText = `Moves: 0`;
            synth.playSwap();
        }

        resize() {
            if(!this.loaded) return;
            const s = document.getElementById('stage');
            const maxW = s.clientWidth - 20; const maxH = s.clientHeight - 20;
            const iR = this.img.width / this.img.height;
            const cR = maxW / maxH;
            let w, h;
            if(iR > cR) { w = maxW; h = maxW / iR; } else { h = maxH; w = maxH * iR; }
            this.c.width = w; this.c.height = h;

            // Recalculate cols based on aspect ratio to keep tiles square
            // We keep "rows" as the complexity anchor
            // if rows=4, and image is 1:2 ratio, cols should be 2
            
            const cellH = h / this.rows;
            const cellW = cellH; // Square tiles desired
            // But we must fill width W.
            // So Cols = w / cellH?
            // Let's adapt slightly: keep rows fixed by setGrid, adapt cols.
            this.cols = Math.round(w / (h / this.rows));
            if(this.cols < 2) this.cols = 2;

            this.w = w / this.cols; this.h = h / this.rows;
            
            if(this.tiles.length === this.rows*this.cols) {
                this.tiles.forEach(t => { t.currX = t.c * this.w; t.currY = t.r * this.h; });
            }
        }

        makeTiles() {
            this.tiles = [];
            for(let r=0; r<this.rows; r++) {
                for(let c=0; c<this.cols; c++) {
                    this.tiles.push({
                        r, c, or: r, oc: c,
                        currX: c*this.w, currY: r*this.h,
                        glow: 0
                    });
                }
            }
        }

        down(x, y) {
            if(!this.isPlaying) return;
            const t = this.getTile(x, y);
            if(t) { this.activeTile = t; synth.init(); }
        }
        
        move(x, y) {
            this.hoverTile = this.getTile(x, y);
        }
        
        up() {
            if(this.activeTile && this.hoverTile && this.activeTile !== this.hoverTile) {
                this.swap(this.activeTile, this.hoverTile);
            }
            this.activeTile = null; this.hoverTile = null;
        }

        getTile(x, y) {
            const r = this.c.getBoundingClientRect();
            const cx = (x - r.left)*(this.c.width/r.width);
            const cy = (y - r.top)*(this.c.height/r.height);
            const c = Math.floor(cx/this.w); const row = Math.floor(cy/this.h);
            return this.tiles.find(t => t.r === row && t.c === c);
        }

        swap(t1, t2) {
            const tr = t1.r; const tc = t1.c;
            t1.r = t2.r; t1.c = t2.c;
            t2.r = tr; t2.c = tc;
            this.moves++;
            document.getElementById('counter').innerText = `Moves: ${this.moves}`;
            synth.playSwap();
            if(t1.r===t1.or && t1.c===t1.oc) { t1.glow=1; synth.playSnap(); }
            if(t2.r===t2.or && t2.c===t2.oc) { t2.glow=1; synth.playSnap(); }
            if(this.tiles.every(t=>t.r===t.or && t.c===t.oc)) this.win();
        }

        win() {
            this.isPlaying = false;
            synth.playWin();
            document.getElementById('stage').classList.add('stage-win');
            for(let i=0; i<100; i++) this.particles.push(new Particle(this.c.width, this.c.height));
            setTimeout(() => {
                gallery.save(this.c.toDataURL('image/jpeg', 0.5), this.moves);
                document.getElementById('win').classList.add('visible');
            }, 2000);
        }

        next() {
            document.getElementById('win').classList.remove('visible');
            document.getElementById('stage').classList.remove('stage-win');
            this.particles = [];
            ads.show();
        }
        
        showHint() { document.getElementById('hint-overlay').classList.add('visible'); }
        hideHint() { document.getElementById('hint-overlay').classList.remove('visible'); }
        
        toggleFullscreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(()=>{});
            else if (document.exitFullscreen) document.exitFullscreen();
        }

        loop() {
            this.update();
            this.draw();
            requestAnimationFrame(() => this.loop());
        }

        update() {
            this.tiles.forEach(t => {
                const tx = t.c * this.w; const ty = t.r * this.h;
                t.currX += (tx - t.currX) * 0.25;
                t.currY += (ty - t.currY) * 0.25;
                if(t.glow > 0) t.glow -= 0.05;
            });
            this.particles.forEach(p => p.update());
        }

        draw() {
            if(!this.loaded) return;
            this.ctx.clearRect(0,0,this.c.width, this.c.height);
            const sw = this.img.width/this.cols; const sh = this.img.height/this.rows;
            
            [...this.tiles].sort((a,b) => (a===this.activeTile ? 1 : -1)).forEach(t => {
                const x = t.currX; const y = t.currY;
                this.ctx.save();
                if(t===this.activeTile) {
                    this.ctx.translate(x+this.w/2, y+this.h/2);
                    this.ctx.scale(1.1, 1.1);
                    this.ctx.translate(-(x+this.w/2), -(y+this.h/2));
                    this.ctx.shadowBlur=20; this.ctx.shadowColor="cyan";
                }
                this.ctx.drawImage(this.img, t.oc*sw, t.or*sh, sw, sh, x, y, this.w+0.5, this.h+0.5);
                if(t.glow > 0) {
                    this.ctx.fillStyle = `rgba(255,255,255,${t.glow})`;
                    this.ctx.fillRect(x,y,this.w,this.h);
                }
                const correct = t.r===t.or && t.c===t.oc;
                if(!this.isPlaying || !correct) {
                    this.ctx.strokeStyle="rgba(0,0,0,0.2)";
                    this.ctx.strokeRect(x,y,this.w,this.h);
                }
                this.ctx.restore();
            });
            
            this.particles.forEach(p => p.draw(this.ctx));
            
            if(this.activeTile && this.hoverTile && this.activeTile !== this.hoverTile) {
                this.ctx.strokeStyle = "rgba(255,255,255,0.8)";
                this.ctx.lineWidth = 4;
                this.ctx.strokeRect(this.hoverTile.currX, this.hoverTile.currY, this.w, this.h);
            }
        }
    }

    const game = new Momsaic();

</script>
</body>
</html>


