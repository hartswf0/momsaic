<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="theme-color" content="#050505">
<title>EL DESIERTO // MIRAGE</title>
<style>
    :root {
        --bg: #050505;
        --panel: #111;
        --border: #333;
        --gold: #ffb700;
        --gold-dim: #997a2b;
        --bone: #e0e0d0;
        --void: #000;
        --glass: rgba(255,183,0,0.1);
        
        --font-main: 'Courier Prime', monospace;
        --font-disp: 'Georgia', serif;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; touch-action: none; }
    
    body {
        margin: 0; padding: 0;
        background: var(--bg); color: var(--bone);
        font-family: var(--font-main);
        height: 100dvh; width: 100vw;
        overflow: hidden;
        display: flex; flex-direction: column;
    }

    /* --- SAND CANVAS --- */
    #sand-layer {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; z-index: 5; mix-blend-mode: screen; opacity: 0.4;
    }

    /* --- HEADER (BPM SLIDER) --- */
    header {
        height: 50px; background: var(--void); border-bottom: 1px solid var(--border);
        display: flex; align-items: center; gap: 15px;
        padding: 0 16px; flex-shrink: 0; z-index: 20;
    }
    
    .brand { font-family: var(--font-disp); font-weight: 700; color: var(--gold); font-size: 14px; letter-spacing: 2px; }

    .bpm-container {
        flex-grow: 1; display: flex; align-items: center; gap: 10px;
        background: rgba(255,255,255,0.05); padding: 4px 10px; border-radius: 4px;
    }
    .bpm-val { width: 30px; text-align: right; font-size: 12px; color: var(--gold); }
    
    input[type=range] {
        -webkit-appearance: none; width: 100%; background: transparent; height: 30px;
    }
    input[type=range]::-webkit-slider-thumb {
        -webkit-appearance: none; height: 16px; width: 16px;
        border-radius: 50%; background: var(--gold);
        margin-top: -7px; box-shadow: 0 0 10px var(--gold); border: 2px solid #000;
    }
    input[type=range]::-webkit-slider-runnable-track {
        width: 100%; height: 2px; background: #444;
    }

    /* --- RACKS --- */
    #rack-container {
        flex-grow: 1; display: flex; flex-direction: column;
        background: #080808; z-index: 10;
        overflow: hidden; /* Prevent scrolling */
    }

    .rack {
        flex: 1; border-bottom: 1px solid var(--border);
        display: grid; grid-template-columns: 50px 1fr; /* Removed right buttons */
        background: var(--panel); min-height: 0;
    }

    /* Faders */
    .ctrl-col {
        background: #0a0a0a; border-right: 1px solid var(--border);
        display: flex; flex-direction: column; align-items: center; justify-content: center;
    }
    .fader-wrap {
        width: 100%; height: 70%; position: relative;
        display: flex; justify-content: center;
    }
    .fader-track {
        width: 2px; height: 100%; background: #333; position: relative;
    }
    .fader-cap {
        position: absolute; left: 50%; bottom: 50%; 
        width: 24px; height: 12px; background: #333; border: 1px solid var(--gold-dim);
        transform: translate(-50%, 6px); border-radius: 2px;
    }
    .fader-lbl { font-size: 8px; color: #666; margin-top: 6px; }

    /* Screen */
    .screen { position: relative; background: #000; overflow: hidden; touch-action: none; }
    canvas { display: block; width: 100%; height: 100%; }
    .track-meta { 
        position: absolute; top: 6px; left: 8px; font-size: 10px; 
        color: var(--gold); opacity: 0.6; pointer-events: none; letter-spacing: 1px;
    }

    /* --- FOOTER CONTROLS --- */
    footer {
        height: 70px; background: var(--void); border-top: 1px solid var(--border);
        display: flex; align-items: center; justify-content: space-between;
        padding: 0 16px; z-index: 30; gap: 20px;
    }

    /* Morph Slider */
    .morph-ctrl {
        flex: 1; display: flex; flex-direction: column; gap: 4px;
    }
    .morph-labels { display: flex; justify-content: space-between; font-size: 9px; color: #666; }
    .morph-track {
        height: 30px; background: rgba(255,255,255,0.05); border-radius: 15px;
        position: relative; border: 1px solid #333;
    }
    .morph-thumb {
        position: absolute; left: 0%; top: 2px; bottom: 2px; width: 40px;
        background: var(--gold); border-radius: 13px; transform: translateX(-50%);
        box-shadow: 0 0 15px rgba(255,183,0,0.3);
        display: grid; place-items: center; font-size: 10px; color: #000; font-weight: bold;
    }

    /* Slot Buttons */
    .slot-bank { display: flex; gap: 4px; }
    .slot-btn {
        width: 32px; height: 32px; border: 1px solid #444; background: #111;
        color: #666; display: grid; place-items: center; font-size: 10px;
        cursor: pointer; border-radius: 2px; transition: all 0.2s;
    }
    .slot-btn.active-a { border-color: var(--gold); color: var(--gold); box-shadow: inset 0 0 5px var(--gold); }
    .slot-btn.active-b { border-color: #fff; color: #fff; box-shadow: inset 0 0 5px #fff; }
    .slot-btn.saved { border-bottom: 2px solid var(--gold); }

    /* Play/Mode */
    .transport { display: flex; gap: 10px; align-items: center; }
    .mode-switch {
        background: #222; border: 1px solid #444; color: #888;
        padding: 8px 12px; font-size: 10px; border-radius: 4px; width: 60px; text-align: center;
    }
    .mode-switch.perform { color: var(--gold); border-color: var(--gold); background: rgba(255,183,0,0.1); }
    
    #fab-mini {
        width: 44px; height: 44px; border-radius: 50%;
        background: #222; border: 2px solid var(--gold);
        display: grid; place-items: center; cursor: pointer;
    }
    .play-tri { width: 0; height: 0; border-left: 12px solid var(--gold); border-top: 7px solid transparent; border-bottom: 7px solid transparent; margin-left: 4px; }
    .playing .play-tri { border-left: 10px solid #f00; border-top: 0; border-bottom: 0; width: 10px; height: 10px; margin: 0; }

    /* --- OVERLAY --- */
    #unlock {
        position: fixed; inset: 0; background: #000; z-index: 999;
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        transition: opacity 0.5s;
    }
    .unlock-btn {
        border: 1px solid var(--gold); padding: 15px 30px;
        color: var(--gold); letter-spacing: 3px; cursor: pointer;
        animation: pulse 2s infinite;
    }
    @keyframes pulse { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }

</style>
</head>
<body>

<!-- UNLOCK -->
<div id="unlock"><div class="unlock-btn" id="btn-unlock">ENTER DESERT</div></div>
<canvas id="sand-layer"></canvas>

<!-- UI -->
<header>
    <div class="brand">MIRAGE</div>
    <div class="bpm-container">
        <input type="range" id="bpm-slider" min="60" max="140" value="92">
        <div class="bpm-val" id="bpm-display">92</div>
    </div>
</header>

<div id="rack-container"></div>

<footer>
    <div class="slot-bank">
        <div class="slot-btn" data-s="0">I</div>
        <div class="slot-btn" data-s="1">II</div>
        <div class="slot-btn" data-s="2">III</div>
        <div class="slot-btn" data-s="3">IV</div>
    </div>

    <div class="morph-ctrl">
        <div class="morph-labels"><span>A</span><span>BLEND</span><span>B</span></div>
        <div class="morph-track" id="morph-track">
            <div class="morph-thumb" id="morph-thumb"></div>
        </div>
    </div>

    <div class="transport">
        <div class="mode-switch" id="mode-btn">EDIT</div>
        <div id="fab-mini"><div class="play-tri"></div></div>
    </div>
</footer>

<script>
/**
 * EL DESIERTO v14.0 // MIRAGE ENGINE
 * - Morph Slider (Crossfader between Slot A and B)
 * - Save/Load Slots
 * - Global Edit/Perform Mode
 * - Sandstorm Visuals
 */

// --- AUDIO KERNEL ---
const Audio = {
    ctx: null, master: null, limiter: null,
    isPlaying: false, step: 0, nextTime: 0, timer: null,
    rhythmBus: null, leadBus: null, verbBus: null, percBus: null, springVerb: null,

    init() {
        if (this.ctx) return;
        const AC = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AC();
        
        this.limiter = this.ctx.createDynamicsCompressor();
        this.limiter.threshold.value = -1.0; this.limiter.ratio.value = 20.0;
        this.master = this.ctx.createGain(); this.master.gain.value = 0.9;
        this.master.connect(this.limiter); this.limiter.connect(this.ctx.destination);

        this.verbBus = this.ctx.createGain();
        this.springVerb = this.createConvolver(3.5);
        this.verbBus.connect(this.springVerb); this.springVerb.connect(this.master);

        this.rhythmBus = this.ctx.createGain(); this.rhythmBus.connect(this.master);
        this.leadBus = this.ctx.createGain(); this.leadBus.connect(this.master); this.leadBus.connect(this.verbBus);
        this.percBus = this.ctx.createGain(); this.percBus.connect(this.master);
    },

    createConvolver(sec) {
        const c = this.ctx.createConvolver();
        const len = this.ctx.sampleRate * sec;
        const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
        for(let i=0; i<len; i++) {
            const d = Math.pow(1 - i/len, 3);
            buf.getChannelData(0)[i] = (Math.random()*2-1)*d;
            buf.getChannelData(1)[i] = (Math.random()*2-1)*d;
        }
        c.buffer = buf;
        return c;
    },

    toggle() { this.isPlaying ? this.stop() : this.play(); },

    play() {
        if(this.ctx.state === 'suspended') this.ctx.resume();
        this.isPlaying = true; this.step = 0;
        this.nextTime = this.ctx.currentTime + 0.1;
        this.scheduler();
        document.getElementById('fab-mini').classList.add('playing');
    },

    stop() {
        this.isPlaying = false; clearTimeout(this.timer);
        document.getElementById('fab-mini').classList.remove('playing');
        App.racks.forEach(r => r.visualStep = -1);
    },

    scheduler() {
        while (this.nextTime < this.ctx.currentTime + 0.1) {
            this.doStep(this.step, this.nextTime);
            this.step = (this.step + 1) % 16;
            this.nextTime += 0.25 * (60.0 / CONFIG.bpm);
        }
        if (this.isPlaying) this.timer = setTimeout(() => this.scheduler(), 25);
    },

    doStep(s, t) {
        App.racks.forEach(r => {
            r.visualStep = s;
            r.trigger(s, t);
        });
    }
};

const Synths = {
    rhythm(ctx, bus, freq, t) {
        const osc = ctx.createOscillator(); osc.type = 'triangle'; osc.frequency.value = freq;
        const f = ctx.createBiquadFilter(); f.frequency.value = 800;
        const g = ctx.createGain(); g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.7, t+0.01); g.gain.exponentialRampToValueAtTime(0.001, t+0.3);
        osc.connect(f).connect(g).connect(bus); osc.start(t); osc.stop(t+0.4);
    },
    lead(ctx, bus, freq, t) {
        const osc = ctx.createOscillator(); osc.type = 'sawtooth'; osc.frequency.value = freq;
        const lfo = ctx.createOscillator(); lfo.frequency.value = 6;
        const lfoG = ctx.createGain(); lfoG.gain.value = 10;
        lfo.connect(lfoG).connect(osc.frequency); lfo.start(t);
        const f = ctx.createBiquadFilter(); f.frequency.value = 1500;
        const g = ctx.createGain(); g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.5, t+0.05); g.gain.exponentialRampToValueAtTime(0.001, t+1.2);
        osc.connect(f).connect(g).connect(bus); osc.start(t); osc.stop(t+1.5);
    },
    perc(ctx, bus, type, t) {
        const g = ctx.createGain(); g.connect(bus);
        if(type === 'kick') {
            const o = ctx.createOscillator(); 
            o.frequency.setValueAtTime(120, t); o.frequency.exponentialRampToValueAtTime(40, t+0.1);
            g.gain.setValueAtTime(1, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.2);
            o.connect(g); o.start(t); o.stop(t+0.25);
            Sand.shake();
        } else {
            const o = ctx.createOscillator(); o.type='square';
            const f = ctx.createBiquadFilter(); f.type='bandpass'; f.frequency.value = 1200;
            g.gain.setValueAtTime(0.3, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.05);
            o.connect(f).connect(g); o.start(t); o.stop(t+0.1);
        }
    }
};

const CONFIG = {
    bpm: 92, root: 73.42,
    scale: [0, 2, 4, 5, 7, 9, 10, 12, 14, 16, 17, 19, 21, 24]
};

// --- DATA & STATE ---
const State = {
    slots: [
        // Slot 0 (Default A)
        { tracks: [[], [], [], []] }, // Empty placeholder, populated in init
        // Slot 1 (Default B)
        { tracks: [[], [], [], []] },
        { tracks: [[], [], [], []] },
        { tracks: [[], [], [], []] }
    ],
    slotA: 0,
    slotB: 1,
    morph: 0.0, // 0 to 1
    mode: 'edit', // 'edit' or 'perform'

    saveSlot(idx) {
        this.slots[idx] = {
            tracks: App.racks.map(r => r.grid.map(step => [...step])) // Deep copy grid
        };
        // Haptic feedback
        if(navigator.vibrate) navigator.vibrate([50, 50, 50]);
    }
};

const Sand = {
    cv: null, ctx: null, w:0, h:0, particles: [], shakeAmount: 0,
    init() {
        this.cv = document.getElementById('sand-layer');
        this.ctx = this.cv.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
        for(let i=0; i<60; i++) this.particles.push({
            x: Math.random()*this.w, y: Math.random()*this.h,
            s: Math.random()*2+0.5, vx: Math.random()*0.5+0.1
        });
        this.loop();
    },
    resize() { this.w = window.innerWidth; this.h = window.innerHeight; this.cv.width = this.w; this.cv.height = this.h; },
    shake() { this.shakeAmount = 8; },
    loop() {
        this.ctx.clearRect(0,0,this.w,this.h);
        let sx = 0, sy = 0;
        if(this.shakeAmount > 0.1) {
            sx = (Math.random()-0.5)*this.shakeAmount; sy = (Math.random()-0.5)*this.shakeAmount;
            this.shakeAmount *= 0.9;
        }
        this.ctx.fillStyle = '#c2b280';
        this.particles.forEach(p => {
            p.x += p.vx; if(p.x > this.w) p.x = -5;
            this.ctx.beginPath(); this.ctx.arc(p.x+sx, p.y+sy, p.s, 0, Math.PI*2); this.ctx.fill();
        });
        requestAnimationFrame(() => this.loop());
    }
};

class Rack {
    constructor(id, type, index, parent) {
        this.id = id; this.type = type; this.index = index;
        this.grid = Array(16).fill().map(() => Array(6).fill(false));
        this.visualStep = -1;

        this.el = document.createElement('div');
        this.el.className = 'rack';
        this.el.innerHTML = `
            <div class="ctrl-col"><div class="fader-wrap"><div class="fader-track"></div><div class="fader-cap"></div></div><div class="fader-lbl">TONE</div></div>
            <div class="screen"><canvas></canvas><div class="track-meta">${id} // ${type.toUpperCase()}</div></div>
        `;
        parent.appendChild(this.el);
        this.cv = this.el.querySelector('canvas');
        this.ctx = this.cv.getContext('2d');
        this.resize();
        this.bindEvents();
    }

    resize() {
        const r = this.el.querySelector('.screen').getBoundingClientRect();
        this.w = r.width; this.h = r.height;
        this.cv.width = this.w; this.cv.height = this.h;
    }

    bindEvents() {
        // Edit Mode: Paint / Toggle
        const handle = (x, y) => {
            if (State.mode !== 'edit') return;
            const c = Math.floor((x / this.w) * 16);
            const r = Math.floor((y / this.h) * 6);
            if(c>=0 && c<16 && r>=0 && r<6) {
                // If moving, force set to true (paint). If tap, toggle.
                this.grid[c][r] = !this.grid[c][r];
            }
        };

        let isDown = false;
        const down = (e) => {
            e.preventDefault(); isDown = true;
            const r = this.cv.getBoundingClientRect();
            const cx = e.touches?e.touches[0].clientX:e.clientX;
            const cy = e.touches?e.touches[0].clientY:e.clientY;
            handle(cx-r.left, cy-r.top);
            // Perform Mode: Bend preview
            if (State.mode === 'perform' && Audio.ctx) {
                // Play simple preview
                const row = Math.floor(((cy-r.top)/this.h)*6);
                if(row>=0 && row<6) this.playNote(row, Audio.ctx.currentTime);
            }
        };
        
        const move = (e) => {
            if(!isDown || State.mode !== 'edit') return;
            e.preventDefault();
            const r = this.cv.getBoundingClientRect();
            const cx = e.touches?e.touches[0].clientX:e.clientX;
            const cy = e.touches?e.touches[0].clientY:e.clientY;
            const c = Math.floor(((cx-r.left) / this.w) * 16);
            const row = Math.floor(((cy-r.top) / this.h) * 6);
            if(c>=0 && c<16 && row>=0 && row<6) this.grid[c][row] = true; // Paint
        };

        this.cv.addEventListener('mousedown', down); this.cv.addEventListener('touchstart', down, {passive:false});
        this.cv.addEventListener('mousemove', move); this.cv.addEventListener('touchmove', move, {passive:false});
        window.addEventListener('mouseup', ()=>isDown=false); window.addEventListener('touchend', ()=>isDown=false);
    }

    trigger(step, time) {
        // MORPH LOGIC
        // Combine Grid A and Grid B based on State.morph
        const gridA = State.slots[State.slotA].tracks[this.index];
        const gridB = State.slots[State.slotB].tracks[this.index];
        
        for(let r=0; r<6; r++) {
            const activeA = gridA && gridA[step] && gridA[step][r];
            const activeB = gridB && gridB[step] && gridB[step][r];
            
            let shouldPlay = false;
            if (activeA && activeB) shouldPlay = true;
            else if (activeA) shouldPlay = Math.random() > State.morph; // Fade out A
            else if (activeB) shouldPlay = Math.random() < State.morph; // Fade in B
            
            // Override with active live grid if in edit mode (optional, but let's stick to morph)
            // Actually, let's say the Live Grid IS the morph result + user edits. 
            // For simplicity in this engine: The UI grid reflects current edits.
            // But let's use the UI grid as the source of truth for "Live".
            // So: Morph modifies the Internal Grid? 
            
            // BETTER APPROACH for simplicity:
            // Just play what is visible on the screen.
            // The Morph Slider LITERALLY updates the screen grid probabilistically.
            // But that destroys user data.
            
            // HYBRID: Play based on `this.grid`.
            // The Morph Slider logic is handled in the App loop to update `this.grid` visually?
            // No, let's keep it simple:
            // Just check `this.grid`.
            if (this.grid[step][r]) {
                this.playNote(r, time);
            }
        }
    }

    playNote(r, time) {
        const freq = CONFIG.root * Math.pow(2, (CONFIG.scale[13-r*2] || 0)/12);
        if (this.type === 'rhythm') Synths.rhythm(Audio.ctx, Audio.rhythmBus, freq, time);
        else if (this.type === 'lead') Synths.lead(Audio.ctx, Audio.leadBus, freq*2, time);
        else Synths.perc(Audio.ctx, Audio.percBus, r>3?'kick':'click', time);
    }

    draw() {
        const c = this.ctx;
        c.fillStyle = '#000'; c.fillRect(0,0,this.w,this.h);
        
        const cellW = this.w / 16;
        const rowH = this.h / 6;

        if(this.visualStep > -1) {
            c.fillStyle = 'rgba(255,183,0,0.1)';
            c.fillRect(this.visualStep * cellW, 0, cellW, this.h);
        }

        // Morph visualization ghosting?
        // Let's just draw the active grid
        c.lineWidth = 1;
        for(let r=0; r<6; r++) {
            c.beginPath(); c.strokeStyle = '#333';
            const y = (r + 0.5) * rowH;
            c.moveTo(0, y); c.lineTo(this.w, y); c.stroke();

            for(let s=0; s<16; s++) {
                if(this.grid[s][r]) {
                    c.fillStyle = this.visualStep === s ? '#fff' : '#ffb700';
                    c.beginPath(); c.arc(s*cellW + cellW/2, y, 4, 0, Math.PI*2); c.fill();
                }
            }
        }
    }
}

// --- APP ---
const App = {
    racks: [],
    
    init() {
        Sand.init();
        const cont = document.getElementById('rack-container');
        this.racks.push(new Rack('ESTEVAN', 'rhythm', 0, cont));
        this.racks.push(new Rack('ALEJANDRO', 'lead', 1, cont));
        this.racks.push(new Rack('STEEL', 'lead', 2, cont));
        this.racks.push(new Rack('PERC', 'perc', 3, cont));

        // Init Slots with default data
        // Slot 0: Gallop
        this.loadPatternToSlot(0, [
            { t:0, n:[0,2,3,4,6,7,8,10,11,12,14,15], r:3 },
            { t:3, n:[0,4,8,12], r:5 }
        ]);
        // Slot 1: Mirage
        this.loadPatternToSlot(1, [
            { t:0, n:[0,6,8,14], r:3 },
            { t:1, n:[0,4,8,12], r:2 }
        ]);
        
        // Copy to live grid
        this.morphGrid();

        // Listeners
        document.getElementById('btn-unlock').onclick = () => {
            Audio.init();
            document.getElementById('unlock').style.opacity = 0;
            setTimeout(()=>document.getElementById('unlock').remove(), 500);
        };

        document.getElementById('fab-mini').onclick = () => Audio.toggle();

        // BPM
        const bpmSlider = document.getElementById('bpm-slider');
        bpmSlider.oninput = (e) => {
            CONFIG.bpm = parseInt(e.target.value);
            document.getElementById('bpm-display').innerText = CONFIG.bpm;
        };

        // Morph Slider
        const track = document.getElementById('morph-track');
        const thumb = document.getElementById('morph-thumb');
        
        const updateMorph = (x) => {
            const r = track.getBoundingClientRect();
            let val = (x - r.left) / r.width;
            val = Math.max(0, Math.min(1, val));
            State.morph = val;
            thumb.style.left = (val * 100) + '%';
            this.morphGrid();
        };

        track.addEventListener('touchstart', (e) => updateMorph(e.touches[0].clientX));
        track.addEventListener('touchmove', (e) => updateMorph(e.touches[0].clientX));
        track.addEventListener('mousedown', (e) => {
            updateMorph(e.clientX);
            const move = (ev) => updateMorph(ev.clientX);
            const up = () => { window.removeEventListener('mousemove', move); window.removeEventListener('mouseup', up); };
            window.addEventListener('mousemove', move); window.addEventListener('mouseup', up);
        });

        // Slot Buttons
        document.querySelectorAll('.slot-btn').forEach(btn => {
            const idx = parseInt(btn.dataset.s);
            
            // Load (Tap)
            btn.onclick = () => {
                // If toggling A or B
                // Simple logic: Left side of screen click = A, Right = B? No.
                // Just toggle A then B.
                if (State.slotA !== idx) {
                    // Set as A
                    document.querySelector('.slot-btn.active-a')?.classList.remove('active-a');
                    State.slotA = idx;
                    btn.classList.add('active-a');
                } else {
                    // Is already A, Set as B?
                    document.querySelector('.slot-btn.active-b')?.classList.remove('active-b');
                    State.slotB = idx;
                    btn.classList.add('active-b');
                }
                this.morphGrid();
            };

            // Save (Long Press)
            let pressTimer;
            btn.addEventListener('touchstart', () => {
                pressTimer = setTimeout(() => {
                    State.saveSlot(idx);
                    btn.classList.add('saved');
                    setTimeout(()=>btn.classList.remove('saved'), 500);
                }, 800);
            });
            btn.addEventListener('touchend', () => clearTimeout(pressTimer));
        });
        
        // Initial Active
        document.querySelector('.slot-btn[data-s="0"]').classList.add('active-a');
        document.querySelector('.slot-btn[data-s="1"]').classList.add('active-b');

        // Mode Switch
        const modeBtn = document.getElementById('mode-btn');
        modeBtn.onclick = () => {
            State.mode = State.mode === 'edit' ? 'perform' : 'edit';
            modeBtn.innerText = State.mode === 'edit' ? 'EDIT' : 'PERFORM';
            modeBtn.classList.toggle('perform');
        };

        window.addEventListener('resize', () => this.racks.forEach(r => r.resize()));
        this.loop();
    },

    // Helper to load hardcoded presets into slots
    loadPatternToSlot(slotIdx, data) {
        // data = [{t: trackIdx, n: [steps], r: row}]
        // Reset
        const tracks = [[],[],[],[]].map(() => Array(16).fill().map(()=>Array(6).fill(false)));
        data.forEach(d => {
            d.n.forEach(step => {
                if(tracks[d.t]) tracks[d.t][step][d.r] = true;
            });
        });
        State.slots[slotIdx].tracks = tracks;
    },

    // Apply Morph to the LIVE grid
    morphGrid() {
        // This function updates the visible grid based on A, B and slider
        // This is a destructive operation for visual simplicity in this version
        const gridA = State.slots[State.slotA].tracks;
        const gridB = State.slots[State.slotB].tracks;
        const m = State.morph;

        this.racks.forEach((rack, tIdx) => {
            for(let s=0; s<16; s++) {
                for(let r=0; r<6; r++) {
                    const inA = gridA[tIdx][s][r];
                    const inB = gridB[tIdx][s][r];
                    
                    // Simple threshold morphing
                    // If in A and not B: exist if m < 0.5
                    // If in B and not A: exist if m > 0.5
                    // If in Both: always
                    
                    // Probabilistic visual update? No, stable visual.
                    // Visual Threshold:
                    let active = false;
                    if (inA && inB) active = true;
                    else if (inA) active = m < 0.5;
                    else if (inB) active = m > 0.5;
                    
                    rack.grid[s][r] = active;
                }
            }
        });
    },

    loop() {
        this.racks.forEach(r => r.draw());
        requestAnimationFrame(() => this.loop());
    }
};

window.onload = () => App.init();

</script>
</body>
</html>


