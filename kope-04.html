<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#121212">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="EL DESIERTO">
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap"
        rel="stylesheet">
    <title>EL DESIERTO // PRO</title>
    <style>
        :root {
            --bg: #0a0a0a;
            --panel: #141414;
            --border: #2a2a2a;
            --gold: #f5a623;
            --gold-dim: #a67c1a;
            --blue: #3b82f6;
            --bone: #f0f0f0;
            --rec: #ef4444;
            --cut: #10b981;

            --c-rhythm: #fb923c;
            --c-lead: #facc15;
            --c-swell: #93c5fd;
            --c-perc: #f5f5f5;

            --font-main: 'JetBrains Mono', 'SF Mono', 'Menlo', monospace;
            --font-disp: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;

            --safe-top: env(safe-area-inset-top, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --safe-left: env(safe-area-inset-left, 0px);
            --safe-right: env(safe-area-inset-right, 0px);
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }

        /* Allow touch-action on specific elements */
        html,
        body {
            touch-action: manipulation;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            background: var(--bg);
            color: var(--bone);
            font-family: var(--font-main);
            height: 100%;
            width: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        #sand-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            mix-blend-mode: screen;
            opacity: 0.15;
        }

        header {
            height: 64px;
            background: #080808;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 max(16px, var(--safe-left)) 0 max(16px, var(--safe-right));
            padding-top: var(--safe-top);
            flex-shrink: 0;
            z-index: 20;
            gap: 16px;
        }

        .brand {
            font-family: var(--font-disp);
            font-weight: 700;
            color: var(--gold);
            font-size: 16px;
            letter-spacing: 2px;
            flex-shrink: 0;
            margin-right: 10px;
            transition: opacity 0.2s;
            min-width: 60px;
        }

        .meta-ctrls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-shrink: 0;
        }

        .btn-vintage {
            background: #151515;
            border: 1px solid var(--border);
            color: #888;
            font-family: var(--font-main);
            font-size: 10px;
            padding: 6px 12px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-radius: 2px;
            font-weight: bold;
            position: relative;
            transition: all 0.2s;
            min-width: 80px;
            text-align: center;
        }

        .btn-vintage:active {
            border-color: var(--gold);
            color: var(--gold);
            background: #222;
        }

        .help-btn {
            width: 30px;
            height: 30px;
            border: 1px solid #444;
            border-radius: 50%;
            color: #666;
            display: grid;
            place-items: center;
            font-weight: bold;
            cursor: pointer;
            background: transparent;
            font-size: 14px;
        }

        .help-btn:active {
            background: #fff;
            color: #000;
            border-color: #fff;
        }

        .bpm-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 6px;
            flex: 1;
            min-width: 0;
        }

        .bpm-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .bpm-label {
            font-size: 9px;
            color: #666;
            font-weight: bold;
            letter-spacing: 1px;
        }

        .bpm-val {
            font-size: 11px;
            color: var(--gold);
            font-weight: bold;
            font-family: var(--font-disp);
        }

        /* FADER STYLES */
        .fader-track {
            background: #222;
            position: relative;
            border-radius: 2px;
        }

        .fader-fill {
            background: #888;
            border-radius: 2px;
            pointer-events: none;
            position: absolute;
        }

        .fader-cap {
            background: #ccc;
            border-radius: 1px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            position: absolute;
        }

        /* Vertical Fader */
        .fader-wrap {
            width: 100%;
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            cursor: ns-resize;
            touch-action: none;
        }

        .fader-wrap .fader-track {
            width: 4px;
            height: 80%;
            top: 10%;
            background: #111;
            border: 1px solid #222;
        }

        .fader-wrap .fader-fill {
            bottom: 0;
            left: 0;
            width: 100%;
            height: 50%;
            transition: height 0.1s, bottom 0.1s;
        }

        .fader-wrap .fader-cap {
            left: 50%;
            bottom: 50%;
            width: 24px;
            height: 12px;
            transform: translate(-50%, 6px);
            background: #444;
            border: 1px solid #666;
            transition: bottom 0.1s;
        }

        /* TRIM MODE FADERS */
        .rack.trimming .fader-fill {
            background: var(--cut) !important;
            opacity: 0.6;
        }

        .rack.trimming .fader-cap {
            border-color: var(--cut);
        }

        /* Horizontal Fader */
        .fader-h {
            width: 100%;
            height: 24px;
            position: relative;
            cursor: ew-resize;
            touch-action: none;
            display: flex;
            align-items: center;
        }

        .fader-h .fader-track {
            width: 100%;
            height: 2px;
            background: #333;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
        }

        .fader-h .fader-fill {
            top: 50%;
            left: 0;
            height: 2px;
            transform: translateY(-50%);
            width: 50%;
        }

        .fader-h .fader-cap {
            top: 50%;
            left: 50%;
            width: 10px;
            height: 20px;
            transform: translate(-5px, -50%);
            background: #ddd;
            border: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }

        .fader-fill.echo {
            background: var(--blue) !important;
            opacity: 0.8;
        }

        .fader-h.bpm .fader-fill {
            background: var(--gold);
        }

        .fader-h.bpm .fader-cap {
            background: var(--gold);
        }

        .rack[data-type="rhythm"] .fader-fill:not(.echo) {
            background: var(--c-rhythm);
        }

        .rack[data-type="lead"] .fader-fill:not(.echo) {
            background: var(--c-lead);
        }

        .rack[data-type="swell"] .fader-fill:not(.echo) {
            background: var(--c-swell);
        }

        .rack[data-type="perc"] .fader-fill:not(.echo) {
            background: var(--c-perc);
        }

        .rack.recording {
            border: 1px solid var(--rec);
        }

        .rack.recording .track-meta {
            color: var(--rec) !important;
            border-color: var(--rec);
            animation: pulse-rec 1s infinite;
        }

        @keyframes pulse-rec {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .rack.drag-over {
            background: rgba(255, 183, 0, 0.1);
            border: 1px solid var(--gold);
        }

        /* Loading State for Track Meta */
        .track-meta.ready-to-load {
            background: #fff !important;
            color: #000 !important;
            border-color: #fff !important;
            transform: scale(1.05);
        }

        /* --- PRO CONTROL SURFACE (Footer) --- */
        footer {
            height: auto;
            min-height: 90px;
            background: #080808;
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 12px max(16px, var(--safe-left)) calc(12px + var(--safe-bottom)) max(16px, var(--safe-right));
            z-index: 30;
            gap: 12px;
            flex-shrink: 0;
        }

        .control-surface {
            flex: 1;
            height: 60px;
            background: #111;
            border: 1px solid #333;
            border-radius: 4px;
            display: flex;
            align-items: stretch;
            position: relative;
            overflow: hidden;
        }

        .slot-select {
            width: 60px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: var(--font-disp);
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            z-index: 5;
            color: #444;
            border: 1px solid transparent;
        }

        .slot-select:active {
            transform: scale(0.95);
        }

        .slot-select.slot-a {
            border-right: 1px solid #333;
        }

        .slot-select.slot-b {
            border-left: 1px solid #333;
        }

        .slot-select.active-edit-a {
            color: #000;
            background: var(--gold);
            border-bottom: 2px solid var(--gold);
        }

        .slot-select.active-edit-b {
            color: #000;
            background: var(--blue);
            border-bottom: 2px solid var(--blue);
        }

        .slot-select span {
            font-size: 9px;
            opacity: 0.7;
            font-family: var(--font-main);
            margin-top: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 90%;
        }

        .morph-zone {
            flex: 1;
            position: relative;
            cursor: ew-resize;
            touch-action: none;
            background: radial-gradient(circle at center, #1a1a1a 0%, #111 100%);
        }

        .morph-track-line {
            position: absolute;
            top: 50%;
            left: 10px;
            right: 10px;
            height: 4px;
            background: #222;
            transform: translateY(-50%);
            border-radius: 2px;
        }

        .morph-fill-bar {
            position: absolute;
            top: 50%;
            left: 10px;
            height: 4px;
            width: 50%;
            background: linear-gradient(90deg, var(--gold) 0%, var(--blue) 100%);
            transform: translateY(-50%);
            opacity: 0.9;
        }

        .morph-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 44px;
            background: #ccc;
            transform: translate(-50%, -50%);
            border-radius: 2px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        .morph-knob::after {
            content: '';
            position: absolute;
            top: 12px;
            bottom: 12px;
            left: 50%;
            width: 2px;
            background: #666;
            transform: translateX(-50%);
        }

        .morph-labels-float {
            position: absolute;
            bottom: 4px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 70px;
            pointer-events: none;
            font-size: 9px;
            color: #555;
            font-weight: bold;
        }

        /* RACK STYLES */
        #rack-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #000;
            z-index: 10;
            overflow: hidden;
            min-height: 0;
        }

        .rack {
            flex: 1;
            border-bottom: 1px solid var(--border);
            display: grid;
            grid-template-columns: 50px 1fr 50px;
            background: var(--panel);
            min-height: 80px;
            position: relative;
        }

        .rack.muted .screen {
            opacity: 0.2;
            filter: grayscale(100%);
        }

        .ctrl-col {
            background: #151515;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            touch-action: none;
            padding: 4px 0;
        }

        .ctrl-col.left {
            border-right: 1px solid var(--border);
        }

        .ctrl-col.right {
            border-left: 1px solid var(--border);
        }

        .fader-lbl {
            font-size: 8px;
            color: #555;
            margin-top: 4px;
            text-align: center;
            font-weight: bold;
            letter-spacing: 1px;
        }

        .screen {
            position: relative;
            background: #000;
            overflow: hidden;
            touch-action: none;
            cursor: crosshair;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
            -webkit-touch-callout: none;
        }

        .track-meta {
            position: absolute;
            top: 6px;
            left: 8px;
            font-size: 10px;
            color: #fff;
            font-weight: bold;
            letter-spacing: 1px;
            pointer-events: auto;
            text-shadow: 0 1px 2px #000;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            background: rgba(0, 0, 0, 0.6);
            transition: all 0.1s;
        }

        .track-meta:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #fff;
        }

        .track-meta:active {
            background: #fff;
            color: #000;
        }

        #fab-mini {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: #111;
            border: 2px solid var(--gold);
            display: grid;
            place-items: center;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            flex-shrink: 0;
        }

        .play-tri {
            width: 0;
            height: 0;
            border-left: 12px solid var(--gold);
            border-top: 7px solid transparent;
            border-bottom: 7px solid transparent;
            margin-left: 4px;
        }

        .playing .play-tri {
            border: none;
            width: 12px;
            height: 12px;
            background: #f00;
            margin: 0;
            border-radius: 2px;
            box-shadow: 0 0 10px #f00;
        }

        .playing#fab-mini {
            border-color: #f00;
        }

        /* Ctrl Buttons */
        .ctrl-btn-std {
            width: 30px;
            height: 20px;
            border: 1px solid #333;
            color: #666;
            display: grid;
            place-items: center;
            font-size: 9px;
            cursor: pointer;
            border-radius: 2px;
            font-weight: bold;
            margin-bottom: 6px;
            background: #1a1a1a;
            transition: all 0.1s;
        }

        .ctrl-btn-std.active {
            border-color: #f44;
            color: #fff;
            background: #d00;
        }

        .ctrl-btn-rec {
            width: 30px;
            height: 30px;
            border: 1px solid #333;
            color: #666;
            display: grid;
            place-items: center;
            font-size: 14px;
            cursor: pointer;
            border-radius: 50%;
            font-weight: bold;
            margin-bottom: 6px;
            background: #1a1a1a;
            transition: all 0.1s;
            border-color: #555;
            margin-bottom: 10px;
        }

        .ctrl-btn-rec:hover {
            border-color: var(--rec);
            color: var(--rec);
        }

        .ctrl-btn-rec.recording {
            background: var(--rec);
            color: #fff;
            border-color: #fff;
            box-shadow: 0 0 10px var(--rec);
        }

        /* CUT/EDIT BUTTON - Now larger and more haptic */
        .ctrl-btn-cut {
            width: 36px;
            height: 22px;
            border: 2px solid #444;
            color: #888;
            display: grid;
            place-items: center;
            font-size: 9px;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
            margin-bottom: 6px;
            background: #111;
            transition: all 0.15s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .ctrl-btn-cut:hover {
            border-color: var(--cut);
            color: var(--cut);
            background: #1a1a1a;
        }

        .ctrl-btn-cut:active {
            border-color: var(--cut);
            color: #000;
            background: var(--cut);
            transform: scale(0.92);
            box-shadow: 0 0 15px var(--cut);
        }

        #unlock {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            inset: 0;
            background: #050505;
            z-index: 3000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s;
        }

        .unlock-btn {
            border: 1px solid var(--gold);
            padding: 15px 30px;
            border-radius: 2px;
            color: var(--gold);
            letter-spacing: 2px;
            cursor: pointer;
            background: #000;
            animation: pulse 2s infinite;
            margin: 10px;
            font-weight: bold;
            font-size: 14px;
            min-width: 200px;
            text-align: center;
        }

        .unlock-text {
            color: #666;
            font-size: 10px;
            margin-top: 20px;
            max-width: 400px;
            text-align: center;
            line-height: 1.6;
            padding: 0 20px;
        }

        .unlock-text strong {
            color: var(--gold);
        }

        @keyframes pulse {
            0% {
                opacity: 0.8;
                box-shadow: 0 0 10px rgba(255, 183, 0, 0.1);
            }

            50% {
                opacity: 1;
                box-shadow: 0 0 20px rgba(255, 183, 0, 0.2);
            }

            100% {
                opacity: 0.8;
                box-shadow: 0 0 10px rgba(255, 183, 0, 0.1);
            }
        }

        #toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #111;
            border: 1px solid var(--gold);
            padding: 10px 20px;
            color: var(--gold);
            font-size: 16px;
            font-family: var(--font-disp);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 7000;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.9);
            border-radius: 4px;
        }

        #toast.show {
            opacity: 1;
        }

        /* --- SAMPLE EDITOR MODAL --- */
        .sample-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.98);
            z-index: 6000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            animation: fadeIn 0.3s forwards;
        }

        .sm-content {
            width: 95%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .sm-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            width: 100%;
            color: var(--gold);
            font-family: var(--font-disp);
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }

        .sm-waveform-container {
            width: 100%;
            height: 250px;
            background: #111;
            border: 1px solid #444;
            position: relative;
            cursor: grab;
            touch-action: none;
            overflow: hidden;
        }

        .sm-waveform-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Handles & Overlay */
        .sm-overlay {
            position: absolute;
            top: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            pointer-events: none;
        }

        /* FITTS'S LAW COMPLIANT HANDLES - Large, visible, easy to grab */
        .sm-handle {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 48px;
            cursor: ew-resize;
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
            transform: translateX(-24px);
        }

        .sm-handle-grip {
            width: 14px;
            height: 100%;
            border-radius: 7px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            cursor: grab;
        }

        /* Grab indicator pattern - horizontal bars */
        .sm-handle-grip::before,
        .sm-handle-grip::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 2px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 1px;
        }

        .sm-handle-grip::before {
            top: 45%;
        }

        .sm-handle-grip::after {
            top: 55%;
        }

        .sm-handle.start .sm-handle-grip {
            background: linear-gradient(180deg, var(--cut) 0%, #059669 100%);
            box-shadow: 0 0 15px var(--cut), inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .sm-handle.end .sm-handle-grip {
            background: linear-gradient(180deg, var(--rec) 0%, #dc2626 100%);
            box-shadow: 0 0 15px var(--rec), inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        /* Desktop hover state - makes it obvious you can grab */
        .sm-handle:hover .sm-handle-grip {
            transform: scaleX(1.3);
            box-shadow: 0 0 25px currentColor;
        }

        /* Active/dragging state */
        .sm-handle:active .sm-handle-grip,
        .sm-handle.dragging .sm-handle-grip {
            cursor: grabbing;
            transform: scaleX(1.5);
            box-shadow: 0 0 35px currentColor;
        }

        /* Touch Target Extension */
        .sm-handle::before {
            content: '';
            position: absolute;
            width: 60px;
            height: 100%;
            left: -6px;
        }

        .sm-playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #ffff00;
            z-index: 15;
            pointer-events: none;
            display: none;
            box-shadow: 0 0 8px #ffff00;
        }

        /* Time display row */
        .sm-time-row {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #888;
            font-family: var(--font-main);
            padding: 8px 0;
        }

        .sm-time-row span {
            background: #1a1a1a;
            padding: 4px 10px;
            border-radius: 4px;
            border: 1px solid #333;
        }

        .sm-time-row .time-val {
            color: var(--gold);
            font-weight: 600;
        }

        /* Slider Row for ZOOM/PITCH/SPEED - Always stack vertically for mobile-first */
        .sm-sliders-row {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
            padding: 12px;
            background: #111;
            border-radius: 8px;
            margin: 8px 0;
        }

        .sm-slider-group {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
            min-height: 44px;
            /* Touch target */
        }

        .sm-slider-group label {
            font-size: 10px;
            color: #888;
            font-weight: 700;
            letter-spacing: 1px;
            min-width: 45px;
            text-align: right;
        }

        .sm-slider {
            -webkit-appearance: none;
            appearance: none;
            flex: 1;
            height: 8px;
            background: #222;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid #333;
        }

        .sm-slider:focus {
            outline: none;
            border-color: var(--gold);
        }

        .sm-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: linear-gradient(180deg, var(--gold) 0%, #c78a1d 100%);
            cursor: grab;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
            border: 2px solid #fff2;
        }

        .sm-slider::-moz-range-thumb {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: linear-gradient(180deg, var(--gold) 0%, #c78a1d 100%);
            cursor: grab;
            border: 2px solid #fff2;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
        }

        .sm-slider-val {
            font-size: 12px;
            color: var(--gold);
            font-weight: 700;
            font-family: var(--font-main);
            min-width: 40px;
            text-align: left;
        }

        .sm-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            width: 100%;
            align-items: center;
            padding-top: 8px;
        }

        .sm-controls-row {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .sm-btn {
            background: #1a1a1a;
            border: 2px solid #444;
            color: #ccc;
            padding: 12px 20px;
            font-family: var(--font-disp);
            font-size: 12px;
            cursor: pointer;
            min-width: 90px;
            text-transform: uppercase;
            border-radius: 6px;
            touch-action: manipulation;
            transition: all 0.12s ease;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .sm-btn:hover {
            background: #252525;
            border-color: #555;
            color: #fff;
        }

        .sm-btn:active {
            background: #333;
            transform: scale(0.96);
        }

        .sm-btn.primary {
            border-color: var(--gold);
            color: var(--gold);
            background: rgba(245, 166, 35, 0.1);
        }

        .sm-btn.primary:hover {
            background: rgba(245, 166, 35, 0.2);
        }

        .sm-btn.primary:active {
            background: var(--gold);
            color: #000;
            box-shadow: 0 0 20px var(--gold);
        }

        .sm-btn.danger {
            border-color: var(--rec);
            color: var(--rec);
        }

        .sm-btn.danger:active {
            background: var(--rec);
            color: #fff;
            box-shadow: 0 0 15px var(--rec);
        }

        .sm-btn.secondary {
            border-color: var(--blue);
            color: var(--blue);
        }

        .sm-btn.secondary:active {
            background: var(--blue);
            color: #fff;
        }

        .sm-handle-grip {
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .sm-zoom-ctrl {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
            margin: 0 20px;
        }

        .sm-zoom-label {
            font-size: 10px;
            color: #888;
            white-space: nowrap;
            font-weight: bold;
        }

        .sm-zoom-slider {
            flex: 1;
            -webkit-appearance: none;
            height: 4px;
            background: #333;
            border-radius: 2px;
            width: 100%;
            touch-action: none;
            padding: 20px 0;
            /* Larger touch area */
        }

        .sm-zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--gold);
            cursor: pointer;
            box-shadow: 0 2px 5px #000;
        }

        /* Firefox slider support */
        .sm-zoom-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--gold);
            cursor: pointer;
            box-shadow: 0 2px 5px #000;
            border: none;
        }

        .sm-zoom-slider::-moz-range-track {
            background: #333;
            height: 4px;
            border-radius: 2px;
        }

        .preset-gallery {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            /* Fallback for older browsers */
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 5000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            animation: fadeIn 0.3s forwards;
        }

        @keyframes fadeIn {
            to {
                opacity: 1;
            }
        }

        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            max-width: 600px;
            padding: 20px;
        }

        .preset-thumb {
            border: 1px solid #444;
            border-radius: 4px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
            background: #111;
        }

        .preset-thumb:hover {
            border-color: var(--gold);
            transform: scale(1.02);
        }

        .preset-thumb canvas {
            width: 100%;
            height: auto;
            border-radius: 2px;
        }

        .preset-label {
            text-align: center;
            margin-top: 8px;
            font-weight: bold;
            font-size: 11px;
            color: #888;
            font-family: var(--font-disp);
        }

        .gallery-close {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border: 1px solid #444;
            border-radius: 50%;
            display: grid;
            place-items: center;
            color: #666;
            font-size: 20px;
            cursor: pointer;
        }

        .gallery-close:hover {
            border-color: #fff;
            color: #fff;
        }

        .gallery-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .gallery-btn {
            background: #111;
            border: 1px solid var(--gold);
            color: var(--gold);
            padding: 10px 25px;
            font-family: var(--font-disp);
            font-weight: bold;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            letter-spacing: 2px;
        }

        .gallery-btn:hover {
            background: var(--gold);
            color: #000;
        }

        .gallery-btn:active {
            transform: scale(0.95);
        }

        .gallery-paste-view {
            width: 90%;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 70vh;
        }

        .gallery-paste-area {
            width: 100%;
            flex: 1;
            background: #080808;
            border: 1px solid #333;
            color: #aaa;
            font-family: monospace;
            padding: 10px;
            resize: none;
            border-radius: 4px;
            font-size: 10px;
        }

        .gallery-paste-area:focus {
            outline: none;
            border-color: var(--gold);
        }

        /* === TUTORIAL OVERLAY === */
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 8000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            opacity: 0;
            animation: fadeIn 0.4s ease forwards;
        }

        .tutorial-content {
            max-width: 500px;
            width: 100%;
            background: linear-gradient(180deg, #1a1a1a 0%, #0a0a0a 100%);
            border: 1px solid #333;
            border-radius: 16px;
            padding: 32px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
        }

        .tutorial-title {
            font-family: var(--font-disp);
            font-size: 20px;
            color: var(--gold);
            margin-bottom: 24px;
            letter-spacing: 3px;
            font-weight: 700;
        }

        .tutorial-steps {
            text-align: left;
            margin: 24px 0;
        }

        .tutorial-step {
            display: flex;
            align-items: flex-start;
            gap: 14px;
            padding: 12px 0;
            border-bottom: 1px solid #222;
            color: #bbb;
            font-size: 14px;
            line-height: 1.5;
        }

        .tutorial-step:last-child {
            border-bottom: none;
        }

        .tutorial-step-icon {
            font-size: 22px;
            flex-shrink: 0;
            width: 36px;
            text-align: center;
        }

        .tutorial-step strong {
            color: #fff;
        }

        .tutorial-dismiss {
            margin-top: 20px;
            background: linear-gradient(180deg, var(--gold) 0%, #d4920a 100%);
            border: none;
            color: #000;
            padding: 16px 40px;
            font-family: var(--font-disp);
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            border-radius: 8px;
            letter-spacing: 1px;
            transition: all 0.15s ease;
            box-shadow: 0 4px 20px rgba(245, 166, 35, 0.3);
        }

        .tutorial-dismiss:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 30px rgba(245, 166, 35, 0.4);
        }

        .tutorial-dismiss:active {
            transform: scale(0.98);
        }

        .tutorial-skip {
            display: block;
            margin-top: 16px;
            color: #555;
            font-size: 11px;
            cursor: pointer;
        }

        .tutorial-skip:hover {
            color: #888;
        }
    </style>
</head>

<body>

    <div id="toast"></div>

    <div id="unlock">
        <div style="color:#666; font-size:10px; margin-bottom:20px; letter-spacing:3px; font-weight:bold;">EL DESIERTO
        </div>
        <div class="unlock-btn" id="btn-start">INIT SYSTEM</div>
        <div class="unlock-text">
            <strong>1. TAP GRID</strong> to add/remove notes<br>
            <strong>2. DRAG FADERS</strong> for volume and echo<br>
            <strong>3. TAP PRESET</strong> buttons to switch patterns<br>
            <strong>4. LONG-PRESS TRACK</strong> name to load audio sample<br>
            <strong>5. TAP EDIT</strong> to trim, pitch-shift, slow down samples<br>
            <br>
            <span style="color:#555;">Patterns save per-preset. Samples are global.</span>
        </div>
    </div>

    <canvas id="sand-layer"></canvas>

    <header>
        <div class="brand" id="app-title">GALLOP</div>
        <div class="bpm-container">
            <div class="bpm-header">
                <span class="bpm-label">TEMPO</span>
                <span class="bpm-val" id="bpm-display">92</span>
            </div>
            <div class="fader-h bpm" id="bpm-slider">
                <div class="fader-track"></div>
                <div class="fader-fill" style="width: 30%;"></div>
                <div class="fader-cap" style="left: 30%;"></div>
            </div>
        </div>
        <div class="meta-ctrls">
            <button class="btn-vintage" id="btn-set">SET: TIERRA</button>
            <div class="help-btn" id="btn-help" title="View Presets">◉</div>
        </div>
    </header>

    <div id="rack-container"></div>

    <footer>
        <div class="control-surface">
            <div class="slot-select slot-a active-edit-a" id="slot-a-btn">
                I
                <span id="label-a">SLOT I</span>
            </div>

            <div class="morph-zone" id="morph-track">
                <div class="morph-track-line"></div>
                <div class="morph-fill-bar" id="morph-fill"></div>
                <div class="morph-knob" id="morph-thumb"></div>
            </div>

            <div class="slot-select slot-b" id="slot-b-btn">
                II
                <span id="label-b">SLOT II</span>
            </div>
        </div>

        <div id="fab-mini">
            <div class="play-tri"></div>
        </div>
    </footer>

    <input type="file" id="file-input" accept="audio/*, .mp3, .wav, .json" style="display: none;" />

    <script>
        const $ = id => document.getElementById(id);
        const Toast = msg => {
            const t = $('toast');
            t.innerText = msg;
            t.classList.add('show');
            setTimeout(() => t.classList.remove('show'), 2000);
        };
        const Haptics = {
            enabled: !!navigator.vibrate,
            tick() { if (this.enabled) navigator.vibrate(5); },
            thud() { if (this.enabled) navigator.vibrate([20, 20]); },
            click() { if (this.enabled) navigator.vibrate(10); }
        };

        /* AUDIO ENGINE */
        const Audio = {
            ctx: null, master: null, limiter: null, isPlaying: false, step: 0, nextTime: 0, timer: null,
            rhythm: null, lead: null, swell: null, perc: null,
            buffers: {},
            activeSampleLoadTrack: null,
            trackConfig: {
                rhythm: { start: 0, end: 1 },
                lead: { start: 0, end: 1 },
                swell: { start: 0, end: 1 },
                perc: { start: 0, end: 1 }
            },

            init() {
                if (this.ctx) return;
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                this.limiter = this.ctx.createDynamicsCompressor();
                this.limiter.threshold.value = -1.0; this.limiter.ratio.value = 20.0;
                this.master = this.ctx.createGain();
                this.master.connect(this.limiter);
                this.limiter.connect(this.ctx.destination);
                this.verbBus = this.ctx.createGain();
                this.springVerb = this.createConvolver(3.5);
                this.verbBus.connect(this.springVerb);
                this.springVerb.connect(this.master);

                this.rhythm = this.createChannel('rhythm');
                this.lead = this.createChannel('lead');
                this.swell = this.createChannel('swell');
                this.perc = this.createChannel('perc');
            },
            createChannel(id) {
                const bus = this.ctx.createGain();
                const dry = this.ctx.createGain();
                const send = this.ctx.createGain();
                send.gain.value = 0.3;
                const analyzer = this.ctx.createAnalyser();
                analyzer.fftSize = 256;
                bus.connect(dry);
                dry.connect(this.master);
                bus.connect(send);
                send.connect(this.verbBus);
                const analyzerTap = this.ctx.createGain();
                analyzerTap.gain.value = 1.0;
                dry.connect(analyzerTap);
                analyzerTap.connect(analyzer);
                return { input: bus, dry: dry, send: send, analyzer: analyzer, id: id };
            },
            createConvolver(sec) {
                const c = this.ctx.createConvolver();
                const len = this.ctx.sampleRate * sec;
                const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
                for (let i = 0; i < len; i++) {
                    const d = Math.pow(1 - i / len, 2.5);
                    buf.getChannelData(0)[i] = (Math.random() * 2 - 1) * d;
                    buf.getChannelData(1)[i] = (Math.random() * 2 - 1) * d;
                }
                c.buffer = buf;
                return c;
            },
            createTapeDelay(time, fbAmt, toneFreq) {
                const inp = this.ctx.createGain();
                const out = this.ctx.createGain();
                const delay = this.ctx.createDelay();
                delay.delayTime.value = time;
                const feedback = this.ctx.createGain();
                feedback.gain.value = fbAmt;
                const filter = this.ctx.createBiquadFilter();
                filter.frequency.value = toneFreq;
                const hpf = this.ctx.createBiquadFilter();
                hpf.type = 'highpass'; hpf.frequency.value = 150;
                const shaper = this.ctx.createWaveShaper();
                shaper.curve = this.makeDistortionCurve(5);
                const att = this.ctx.createGain();
                att.gain.value = 0.8;
                inp.connect(delay); delay.connect(filter); filter.connect(shaper);
                shaper.connect(att); att.connect(hpf); hpf.connect(feedback);
                feedback.connect(delay); filter.connect(out);
                return { in: inp, out: out, gain: inp, fb: feedback };
            },
            makeDistortionCurve(amount) {
                const k = amount, n = 44100, curve = new Float32Array(n);
                for (let i = 0; i < n; ++i) {
                    const x = i * 2 / n - 1;
                    curve[i] = (3 + k) * x * 20 * (Math.PI / 180) / (Math.PI + k * Math.abs(x));
                }
                return curve;
            },
            toggle() { this.isPlaying ? this.stop() : this.play(); },
            play() {
                if (this.ctx.state === 'suspended') this.ctx.resume();
                this.isPlaying = true;
                this.step = 0;
                this.nextTime = this.ctx.currentTime + 0.1;
                [this.rhythm, this.lead, this.swell, this.perc].forEach(ch => {
                    if (ch.delay) ch.delay.fb.gain.setTargetAtTime(0.3, this.ctx.currentTime, 0.2);
                });
                this.scheduler();
                $('fab-mini').classList.add('playing');
            },
            stop() {
                this.isPlaying = false;
                clearTimeout(this.timer);
                $('fab-mini').classList.remove('playing');
                App.racks.forEach(r => r.visualStep = -1);
                [this.rhythm, this.lead, this.swell, this.perc].forEach(ch => {
                    if (ch.delay) ch.delay.fb.gain.setTargetAtTime(0, this.ctx.currentTime, 0.05);
                });
            },
            scheduler() {
                while (this.nextTime < this.ctx.currentTime + 0.1) {
                    this.doStep(this.step, this.nextTime);
                    this.step = (this.step + 1) % 16;
                    this.nextTime += 0.25 * (60.0 / CONFIG.bpm);
                }
                if (this.isPlaying) this.timer = setTimeout(() => this.scheduler(), 25);
            },
            doStep(s, t) {
                App.racks.forEach(r => {
                    r.visualStep = s;
                    r.trigger(s, t, State.slotA, State.slotB, State.morph);
                });
            },

            // RECORDING LOGIC
            record(trackId, duration = 1.5) {
                if (!navigator.mediaDevices) return Toast("NO MIC ACCESS");
                navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
                    const mediaRecorder = new MediaRecorder(stream);
                    const chunks = [];
                    mediaRecorder.ondataavailable = e => chunks.push(e.data);
                    mediaRecorder.onstop = async () => {
                        const blob = new Blob(chunks, { type: 'audio/webm' });
                        const arrayBuffer = await blob.arrayBuffer();
                        this.ctx.decodeAudioData(arrayBuffer, (buffer) => {
                            this.buffers[trackId] = buffer;
                            // Reset Trim
                            this.trackConfig[trackId] = { start: 0, end: 1 };
                            console.log(`[KOPE] Recorded audio for ${trackId}, duration: ${buffer.duration.toFixed(2)}s`);
                            Toast(`RECORDED ${trackId.toUpperCase()}`);
                            App.updateTrackLabel(trackId, "CUSTOM");
                            App.refreshTrackUI(trackId);
                        }, (err) => {
                            console.error(`[KOPE] Failed to decode recording:`, err);
                            Toast("DECODE ERROR");
                        });
                    };
                    mediaRecorder.start();
                    console.log(`[KOPE] Started recording for ${trackId}`);
                    Toast("RECORDING...");
                    Haptics.thud();
                    setTimeout(() => { mediaRecorder.stop(); Haptics.click(); }, duration * 1000);
                }).catch(e => { console.error(`[KOPE] Mic error:`, e); Toast("MIC ERROR"); });
            }
        };

        /* SAMPLE EDITOR MODAL LOGIC */
        const SampleEditor = {
            activeTrack: null,
            zoom: 1.0,
            offset: 0.0,
            isPlaying: false,
            playSource: null,

            open(trackId) {
                if (!Audio.buffers[trackId]) return Toast("NO SAMPLE LOADED");

                this.activeTrack = trackId;
                const buffer = Audio.buffers[trackId];
                const config = Audio.trackConfig[trackId];

                // Create Modal Elements
                const overlay = document.createElement('div');
                overlay.className = 'sample-modal';
                overlay.innerHTML = `
            <div class="sm-content">
                <div class="sm-header">
                    <span>EDIT: ${trackId.toUpperCase()}</span>
                    <div class="gallery-close">×</div>
                </div>
                <div class="sm-waveform-container" id="sm-wave-box">
                    <canvas class="sm-waveform-canvas"></canvas>
                    <div class="sm-playhead"></div>
                    <div class="sm-overlay left" style="left:0; width:0%"></div>
                    <div class="sm-overlay right" style="right:0; width:0%"></div>
                    <div class="sm-handle start" style="left:0%"><div class="sm-handle-grip"></div></div>
                    <div class="sm-handle end" style="left:100%"><div class="sm-handle-grip"></div></div>
                </div>
                <div class="sm-time-row">
                    <span>START: <span class="time-val" id="sm-start-time">0.00s</span></span>
                    <span>LOOP: <span class="time-val" id="sm-duration">${buffer.duration.toFixed(2)}s</span></span>
                    <span>END: <span class="time-val" id="sm-end-time">${buffer.duration.toFixed(2)}s</span></span>
                </div>
                <div class="sm-sliders-row">
                    <div class="sm-slider-group">
                        <label>ZOOM</label>
                        <input type="range" class="sm-slider" min="1" max="20" step="0.5" value="1" id="sm-zoom">
                        <span class="sm-slider-val" id="sm-zoom-val">1x</span>
                    </div>
                    <div class="sm-slider-group">
                        <label>PITCH</label>
                        <input type="range" class="sm-slider" min="-12" max="12" step="1" value="0" id="sm-pitch">
                        <span class="sm-slider-val" id="sm-pitch-val">0</span>
                    </div>
                    <div class="sm-slider-group">
                        <label>SPEED</label>
                        <input type="range" class="sm-slider" min="0.25" max="2" step="0.05" value="1" id="sm-speed">
                        <span class="sm-slider-val" id="sm-speed-val">1x</span>
                    </div>
                </div>
                <div class="sm-controls">
                    <div class="sm-controls-row">
                        <button class="sm-btn primary" id="sm-play">PLAY</button>
                        <button class="sm-btn" id="sm-reset">RESET</button>
                        <button class="sm-btn secondary" id="sm-use-synth">USE SYNTH</button>
                        <button class="sm-btn" id="sm-load">LOAD NEW</button>
                    </div>
                    <div class="sm-controls-row" style="margin-top:8px; gap:6px;">
                        <span style="color:#666; font-size:10px; padding:0 4px;">COPY TO:</span>
                        ${['rhythm', 'lead', 'swell', 'perc'].filter(t => t !== trackId).map(t =>
                    `<button class="sm-btn sm-copy-btn" data-target="${t}" style="padding:6px 10px; font-size:10px;">${t.toUpperCase()}</button>`
                ).join('')}
                    </div>
                </div>
            </div>
        `;
                document.body.appendChild(overlay);

                this.canvas = overlay.querySelector('canvas');
                this.playhead = overlay.querySelector('.sm-playhead');
                this.overlay = overlay;
                this.buffer = buffer;

                // Initial Render
                this.render();
                this.updateHandles();
                this.updateTimeDisplay();

                // Events
                overlay.querySelector('.gallery-close').onclick = () => this.close();
                overlay.querySelector('#sm-play').onclick = () => this.togglePlay();
                overlay.querySelector('#sm-load').onclick = () => { State.loadSampleForTrack(trackId); this.close(); };

                // USE SYNTH - switch back to synth mode
                overlay.querySelector('#sm-use-synth').onclick = () => {
                    delete Audio.buffers[trackId];
                    Audio.trackConfig[trackId] = { start: 0, end: 1 };
                    App.updateTrackLabel(trackId, "SYNTH");
                    App.refreshTrackUI(trackId);
                    Toast("SWITCHED TO SYNTH");
                    Haptics.thud();
                    this.close();
                };

                // RESET - restore full sample range and settings
                overlay.querySelector('#sm-reset').onclick = () => {
                    Audio.trackConfig[trackId] = { start: 0, end: 1, pitch: 0, speed: 1 };
                    overlay.querySelector('#sm-pitch').value = 0;
                    overlay.querySelector('#sm-speed').value = 1;
                    overlay.querySelector('#sm-zoom').value = 1;
                    overlay.querySelector('#sm-pitch-val').textContent = '0';
                    overlay.querySelector('#sm-speed-val').textContent = '1x';
                    overlay.querySelector('#sm-zoom-val').textContent = '1x';
                    this.zoom = 1;
                    this.offset = 0;
                    this.updateHandles();
                    this.updateTimeDisplay();
                    this.render();
                    Toast("RESET");
                    Haptics.click();
                };

                // ZOOM slider - centers on trimmed section
                const zoomSlider = overlay.querySelector('#sm-zoom');
                zoomSlider.oninput = (e) => {
                    this.zoom = parseFloat(e.target.value);
                    overlay.querySelector('#sm-zoom-val').textContent = this.zoom.toFixed(1) + 'x';

                    // Center view on trimmed section
                    const cfg = Audio.trackConfig[trackId];
                    const trimCenter = (cfg.start + cfg.end) / 2;
                    const viewWidth = 1 / this.zoom;

                    // Calculate offset to center the trim region
                    this.offset = trimCenter - (viewWidth / 2);

                    // Clamp offset to valid range
                    this.offset = Math.max(0, Math.min(1 - viewWidth, this.offset));

                    this.render();
                    this.updateHandles();
                };

                // PITCH slider (-12 to +12 semitones)
                const pitchSlider = overlay.querySelector('#sm-pitch');
                const cfg = Audio.trackConfig[trackId];
                if (cfg.pitch !== undefined) pitchSlider.value = cfg.pitch;
                pitchSlider.oninput = (e) => {
                    const pitch = parseInt(e.target.value);
                    Audio.trackConfig[trackId].pitch = pitch;
                    const sign = pitch > 0 ? '+' : '';
                    overlay.querySelector('#sm-pitch-val').textContent = sign + pitch;
                };

                // SPEED slider (0.25x to 2x)
                const speedSlider = overlay.querySelector('#sm-speed');
                if (cfg.speed !== undefined) speedSlider.value = cfg.speed;
                speedSlider.oninput = (e) => {
                    const speed = parseFloat(e.target.value);
                    Audio.trackConfig[trackId].speed = speed;
                    overlay.querySelector('#sm-speed-val').textContent = speed.toFixed(2) + 'x';
                };

                // COPY TO buttons - copy sample to other tracks
                overlay.querySelectorAll('.sm-copy-btn').forEach(btn => {
                    btn.onclick = () => {
                        const target = btn.dataset.target;
                        // Copy buffer reference
                        Audio.buffers[target] = Audio.buffers[trackId];
                        // Copy settings (deep copy to allow independent editing)
                        Audio.trackConfig[target] = { ...Audio.trackConfig[trackId] };
                        // Refresh target track UI
                        App.refreshTrackUI(target);
                        Toast(`COPIED TO ${target.toUpperCase()}`);
                        Haptics.click();
                        console.log(`[KOPE] Sample copied from ${trackId} to ${target}`);
                    };
                });

                this.bindDrag();
            },

            close() {
                if (this.playSource) this.playSource.stop();
                this.isPlaying = false;
                document.querySelector('.sample-modal').remove();
            },

            togglePlay() {
                if (this.isPlaying) {
                    if (this.playSource) this.playSource.stop();
                    this.isPlaying = false;
                    this.playhead.style.display = 'none';
                    document.getElementById('sm-play').innerText = "PLAY";
                } else {
                    this.isPlaying = true;
                    document.getElementById('sm-play').innerText = "STOP";
                    this.playLoop();
                }
            },

            playLoop() {
                if (!this.isPlaying) return;
                const cfg = Audio.trackConfig[this.activeTrack];
                const startT = this.buffer.duration * cfg.start;
                const endT = this.buffer.duration * cfg.end;
                const dur = endT - startT;

                this.playSource = Audio.ctx.createBufferSource();
                this.playSource.buffer = this.buffer;
                this.playSource.connect(Audio.master);
                this.playSource.start(0, startT, dur);

                // Animation
                this.playhead.style.display = 'block';
                const startTime = Audio.ctx.currentTime;

                const animate = () => {
                    if (!this.isPlaying) return;
                    const elapsed = Audio.ctx.currentTime - startTime;
                    if (elapsed >= dur) {
                        // Loop
                        this.playLoop();
                        return;
                    }

                    // Calc X position relative to current view
                    const totalPct = cfg.start + (elapsed / this.buffer.duration);

                    // Map global pct to view pct
                    // View window: offset to offset + (1/zoom)
                    const viewW = 1 / this.zoom;
                    const viewStart = this.offset;
                    const viewEnd = viewStart + viewW;

                    if (totalPct >= viewStart && totalPct <= viewEnd) {
                        const screenPct = (totalPct - viewStart) / viewW;
                        this.playhead.style.left = (screenPct * 100) + '%';
                        this.playhead.style.display = 'block';
                    } else {
                        this.playhead.style.display = 'none';
                    }

                    requestAnimationFrame(animate);
                };
                requestAnimationFrame(animate);
            },

            render() {
                const ctx = this.canvas.getContext('2d');
                const w = this.canvas.width = this.canvas.offsetWidth;
                const h = this.canvas.height = this.canvas.offsetHeight;
                const data = this.buffer.getChannelData(0);

                // Determine visible window of sample
                const viewW = 1 / this.zoom;
                const startSample = Math.floor(this.offset * data.length);
                const endSample = Math.floor((this.offset + viewW) * data.length);
                const rangeLen = endSample - startSample;

                const step = Math.ceil(rangeLen / w);
                const amp = h / 2;

                ctx.fillStyle = '#111'; ctx.fillRect(0, 0, w, h);
                ctx.fillStyle = '#ffb700';
                ctx.beginPath();
                for (let i = 0; i < w; i++) {
                    let min = 1.0; let max = -1.0;
                    const idxBase = startSample + (i * step);
                    for (let j = 0; j < step; j++) {
                        if (idxBase + j < data.length) {
                            const datum = data[idxBase + j];
                            if (datum < min) min = datum;
                            if (datum > max) max = datum;
                        }
                    }
                    ctx.fillRect(i, (1 + min) * amp, 1, Math.max(1, (max - min) * amp));
                }
            },

            updateHandles() {
                const config = Audio.trackConfig[this.activeTrack];
                const viewW = 1 / this.zoom;
                const viewStart = this.offset;

                // Convert global pct to screen pct
                const toScreen = (pct) => (pct - viewStart) / viewW * 100;

                const sPct = toScreen(config.start);
                const ePct = toScreen(config.end);

                const startEl = this.overlay.querySelector('.sm-handle.start');
                const endEl = this.overlay.querySelector('.sm-handle.end');

                startEl.style.left = sPct + '%';
                endEl.style.left = ePct + '%';

                // Handle Visibility
                startEl.style.display = (sPct >= -5 && sPct <= 105) ? 'flex' : 'none';
                endEl.style.display = (ePct >= -5 && ePct <= 105) ? 'flex' : 'none';

                this.overlay.querySelector('.sm-overlay.left').style.width = Math.max(0, sPct) + '%';
                this.overlay.querySelector('.sm-overlay.right').style.width = Math.max(0, 100 - ePct) + '%';

                // If overlays cover the whole screen because we are zoomed in deep inside a cut region
                if (sPct > 100) this.overlay.querySelector('.sm-overlay.left').style.width = '100%';
                if (ePct < 0) this.overlay.querySelector('.sm-overlay.right').style.width = '100%';

                // Update time display when handles move
                this.updateTimeDisplay();
            },

            updateTimeDisplay() {
                if (!this.buffer || !this.overlay) return;
                const config = Audio.trackConfig[this.activeTrack];
                const startTime = (this.buffer.duration * config.start).toFixed(2);
                const endTime = (this.buffer.duration * config.end).toFixed(2);
                const duration = ((config.end - config.start) * this.buffer.duration).toFixed(2);

                const startEl = this.overlay.querySelector('#sm-start-time');
                const endEl = this.overlay.querySelector('#sm-end-time');
                const durEl = this.overlay.querySelector('#sm-duration');

                if (startEl) startEl.textContent = startTime + 's';
                if (endEl) endEl.textContent = endTime + 's';
                if (durEl) durEl.textContent = duration + 's';
            },

            bindDrag() {
                const box = this.overlay.querySelector('#sm-wave-box');
                let isDragging = false;

                const handleDrag = (e, type) => {
                    e.preventDefault();
                    e.stopPropagation();
                    isDragging = true;
                    const rect = box.getBoundingClientRect();
                    Haptics.thud();
                    console.log(`[KOPE] Editor drag start: ${type}`);

                    const move = (ev) => {
                        const clientX = ev.touches ? ev.touches[0].clientX : ev.clientX;
                        // Calculate Pct within CURRENT VIEW
                        let screenPct = (clientX - rect.left) / rect.width;

                        // Convert to Global Pct
                        const viewW = 1 / this.zoom;
                        let globalPct = this.offset + (screenPct * viewW);
                        globalPct = Math.max(0, Math.min(1, globalPct));

                        const config = Audio.trackConfig[this.activeTrack];

                        if (type === 'start') {
                            config.start = Math.min(globalPct, config.end - 0.001); // Precision
                        } else if (type === 'end') {
                            config.end = Math.max(globalPct, config.start + 0.001);
                        } else if (type === 'scroll') {
                            // Scroll the view
                            const deltaX = (ev.movementX || (ev.touches && 0)) * -1; // Invert drag
                            // Touch scroll logic is complex, sticking to simple mouse/pad for now or add distinct scroll bar
                            // Simple panning:
                            if (this.zoom > 1) {
                                const panAmt = (ev.movementX / rect.width) * viewW * -1;
                                this.offset = Math.max(0, Math.min(1 - viewW, this.offset + panAmt));
                                this.render();
                            }
                        }

                        this.updateHandles();
                    };

                    const stop = () => {
                        isDragging = false;
                        Haptics.click();
                        const cfg = Audio.trackConfig[this.activeTrack];
                        console.log(`[KOPE] Trim updated: ${this.activeTrack} -> start: ${(cfg.start * 100).toFixed(1)}%, end: ${(cfg.end * 100).toFixed(1)}%`);
                        document.removeEventListener('mousemove', move);
                        document.removeEventListener('mouseup', stop);
                        document.removeEventListener('touchmove', move);
                        document.removeEventListener('touchend', stop);
                    };

                    document.addEventListener('mousemove', move);
                    document.addEventListener('mouseup', stop);
                    document.addEventListener('touchmove', move);
                    document.addEventListener('touchend', stop);
                };

                const startHandle = this.overlay.querySelector('.sm-handle.start');
                const endHandle = this.overlay.querySelector('.sm-handle.end');

                startHandle.onpointerdown = e => handleDrag(e, 'start');
                endHandle.onpointerdown = e => handleDrag(e, 'end');

                // Panning on canvas
                const cv = this.overlay.querySelector('canvas');
                cv.onpointerdown = e => {
                    // If zoomed in, allow panning
                    if (this.zoom > 1) handleDrag(e, 'scroll');
                };
            }
        };

        /* INSTRUMENT DEFINITIONS */
        const InstrumentConfigs = {
            rhythm: [{ name: "WOOD", type: 'triangle', filter: 800 }, { name: "PULSE", type: 'square', filter: 400 }, { name: "GRIT", type: 'sawtooth', filter: 1200 }],
            lead: [{ name: "SAW", type: 'sawtooth', filter: 2000 }, { name: "SINE", type: 'sine', filter: 1000 }, { name: "SQUARE", type: 'square', filter: 3000 }],
            swell: [{ name: "AIR", type: 'sine', filter: 600 }, { name: "PAD", type: 'triangle', filter: 400 }, { name: "SHIMMER", type: 'sawtooth', filter: 800 }],
            perc: [{ name: "KICK/HAT", mod: 1.0 }, { name: "THUD/TICK", mod: 0.5 }, { name: "SLAM/SNAP", mod: 2.0 }]
        };

        const Synths = {
            play(ctx, channelKey, freq, t, vol, type, row) {
                const channel = Audio[channelKey];
                // Check for Custom Sample
                if (Audio.buffers[channelKey]) {
                    const buffer = Audio.buffers[channelKey];
                    const source = ctx.createBufferSource();
                    source.buffer = buffer;

                    const cfg = Audio.trackConfig[channelKey];

                    // Base rate from row position
                    const rowRates = [2.0, 1.5, 1.25, 1.0, 0.75, 0.5];
                    let rate = rowRates[row] || 1.0;

                    // Apply pitch shift (semitones -> rate multiplier)
                    const pitchSemitones = cfg.pitch || 0;
                    const pitchMultiplier = Math.pow(2, pitchSemitones / 12);

                    // Apply speed
                    const speedMultiplier = cfg.speed || 1.0;

                    // Combine all rate modifiers
                    source.playbackRate.value = rate * pitchMultiplier * speedMultiplier;

                    const startOffset = buffer.duration * cfg.start;
                    const duration = ((buffer.duration * cfg.end) - startOffset) / speedMultiplier;

                    const g = ctx.createGain();
                    g.gain.setValueAtTime(vol, t);
                    g.gain.exponentialRampToValueAtTime(0.001, t + duration);

                    source.connect(g).connect(channel.input);
                    if (duration > 0) source.start(t, startOffset, duration * speedMultiplier);
                    return;
                }

                const osc = ctx.createOscillator();
                osc.type = type;
                osc.frequency.value = freq;
                const g = ctx.createGain();
                g.gain.setValueAtTime(0, t);
                g.gain.linearRampToValueAtTime(vol, t + 0.01);
                g.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
                osc.connect(g).connect(channel.input);
                osc.start(t);
                osc.stop(t + 0.5);
            },
            perc(ctx, r, t, vol, mod, patchIdx) {
                const channelKey = 'perc';
                if (Audio.buffers[channelKey]) {
                    const buffer = Audio.buffers[channelKey];
                    const source = ctx.createBufferSource();
                    source.buffer = buffer;
                    source.playbackRate.value = (6 - r) * 0.4;

                    const cfg = Audio.trackConfig[channelKey];
                    const startOffset = buffer.duration * cfg.start;
                    const duration = (buffer.duration * cfg.end) - startOffset;

                    const g = ctx.createGain();
                    g.gain.setValueAtTime(vol, t);

                    source.connect(g).connect(Audio.perc.input);
                    if (duration > 0) source.start(t, startOffset, duration);
                    Sand.shake();
                    return;
                }

                const g = ctx.createGain();
                g.connect(Audio.perc.input);
                if (r > 3) {
                    const o = ctx.createOscillator();
                    o.frequency.setValueAtTime(120 * mod, t);
                    o.frequency.exponentialRampToValueAtTime(40, t + 0.1);
                    g.gain.setValueAtTime(vol, t);
                    g.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
                    o.connect(g); o.start(t); o.stop(t + 0.25); Sand.shake();
                } else {
                    const o = ctx.createOscillator();
                    o.type = 'square';
                    const f = ctx.createBiquadFilter(); f.type = 'bandpass';
                    f.frequency.value = 1200 * mod;
                    g.gain.setValueAtTime(0.3 * vol, t);
                    g.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
                    o.connect(f).connect(g); o.start(t); o.stop(t + 0.1);
                }
            },
            powerUp(ctx) {
                const o = ctx.createOscillator();
                o.type = 'sawtooth';
                o.frequency.setValueAtTime(50, ctx.currentTime);
                o.frequency.exponentialRampToValueAtTime(800, ctx.currentTime + 0.3);
                const g = ctx.createGain();
                g.gain.setValueAtTime(0.2, ctx.currentTime);
                g.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.4);
                o.connect(g).connect(ctx.destination);
                o.start(); o.stop(ctx.currentTime + 0.5);
            }
        };

        const CONFIG = {
            bpm: 92, root: 73.42,
            scale: [0, 2, 4, 5, 7, 9, 10, 12, 14, 16, 17, 19, 21, 24],
            noteNames: ['D', 'E', 'F#', 'G', 'A', 'B', 'C#'],
            trackSounds: [0, 0, 0, 0]
        };

        const State = {
            slots: [
                { set: 0, bpm: 92, sounds: [0, 0, 0, 0], tracks: [[], [], [], []].map(() => Array(16).fill().map(() => Array(6).fill(false))) },
                { set: 1, bpm: 110, sounds: [1, 1, 1, 1], tracks: [[], [], [], []].map(() => Array(16).fill().map(() => Array(6).fill(false))) },
                { set: 2, bpm: 124, sounds: [2, 2, 2, 2], tracks: [[], [], [], []].map(() => Array(16).fill().map(() => Array(6).fill(false))) },
                { set: 0, bpm: 80, sounds: [0, 0, 0, 0], tracks: [[], [], [], []].map(() => Array(16).fill().map(() => Array(6).fill(false))) }
            ],
            slotA: 0, slotB: 1, morph: 0.5,
            sets: ['TIERRA', 'NOCHE', 'SECO'],
            presetNames: ["GALLOP", "MIRAGE", "CANYON", "HORIZON"],

            get activeSlotIndex() { return this.morph > 0.5 ? this.slotB : this.slotA; },

            init() {
                const data = localStorage.getItem('el_desierto_pro_v3');
                if (data) {
                    try {
                        const loaded = JSON.parse(data);
                        if (loaded[0].sounds) this.slots = loaded;
                        else throw new Error("Format Mismatch");
                        Toast("LOADED");
                    } catch (e) {
                        console.error("Save Corrupt or Old", e);
                        this.saveToStorage();
                    }
                }
            },
            saveToStorage() {
                localStorage.setItem('el_desierto_pro_v3', JSON.stringify(this.slots));
            },
            saveSlot(idx) {
                const snap = App.racks.map(r => r.grid.map(step => [...step]));
                this.slots[idx].tracks = snap;
                this.slots[idx].bpm = CONFIG.bpm;
                // Save current visible sounds to slot
                this.slots[idx].sounds = [...this.slots[this.activeSlotIndex].sounds];
                this.saveToStorage();
                Toast("SAVED TO " + this.presetNames[idx]);
            },
            exportData() {
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.slots));
                const dlAnchorElem = document.createElement('a');
                dlAnchorElem.setAttribute("href", dataStr);
                dlAnchorElem.setAttribute("download", "el_desierto_patch.json");
                document.body.appendChild(dlAnchorElem);
                dlAnchorElem.click();
                document.body.removeChild(dlAnchorElem);
                Toast("EXPORTED");
            },
            importData() {
                Audio.activeSampleLoadTrack = null;
                $('file-input').click();
            },
            importFromText(json) {
                try {
                    const data = JSON.parse(json);
                    if (Array.isArray(data) && data.length > 0 && data[0].tracks) {
                        for (let i = 0; i < Math.min(4, data.length); i++) {
                            this.slots[i] = data[i];
                        }
                        this.saveToStorage();
                        App.updateFromState();
                        Toast("IMPORTED TEXT");
                    } else { Toast("INVALID DATA"); }
                } catch (e) { console.error(e); Toast("PARSE ERROR"); }
            },
            loadSampleForTrack(trackId) {
                Audio.activeSampleLoadTrack = trackId;
                $('file-input').click();
            }
        };

        // Handle File Input
        document.getElementById('file-input').addEventListener('change', function (event) {
            const file = event.target.files[0];
            if (!file) return;

            if (Audio.activeSampleLoadTrack) {
                console.log(`[KOPE] Loading sample for track: ${Audio.activeSampleLoadTrack}`);
                const reader = new FileReader();
                reader.onload = function (e) {
                    Audio.ctx.decodeAudioData(e.target.result)
                        .then(buffer => {
                            const trackId = Audio.activeSampleLoadTrack;
                            Audio.buffers[trackId] = buffer;
                            Audio.trackConfig[trackId] = { start: 0, end: 1 }; // Reset Trim
                            console.log(`[KOPE] Sample decoded for ${trackId}: ${buffer.duration.toFixed(2)}s, ${buffer.sampleRate}Hz`);
                            Toast(`SAMPLE LOADED`);
                            Haptics.thud();
                            App.updateTrackLabel(trackId, "CUSTOM");
                            App.refreshTrackUI(trackId);
                            Audio.activeSampleLoadTrack = null;
                            event.target.value = '';
                        })
                        .catch(err => {
                            console.error(`[KOPE] Decode error:`, err);
                            Toast("DECODE ERROR");
                            Audio.activeSampleLoadTrack = null;
                            event.target.value = '';
                        });
                };
                reader.readAsArrayBuffer(file);
                return;
            }

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (Array.isArray(data) && data.length > 0) {
                        State.slots = data;
                        State.saveToStorage();
                        App.updateFromState();
                        Toast("IMPORTED SUCCESSFULLY");
                    } else { Toast("INVALID FILE"); }
                } catch (err) { Toast("IMPORT FAILED"); }
            };
            reader.readAsText(file);
        });

        const Sand = {
            cv: null, ctx: null, w: 0, h: 0, particles: [], shakeAmount: 0,
            init() {
                this.cv = $('sand-layer'); this.ctx = this.cv.getContext('2d');
                this.resize(); window.addEventListener('resize', () => this.resize());
                for (let i = 0; i < 60; i++) this.particles.push({ x: Math.random() * this.w, y: Math.random() * this.h, s: Math.random() * 2 + 0.5, vx: Math.random() * 0.5 + 0.1 });
                this.loop();
            },
            resize() { this.w = window.innerWidth; this.h = window.innerHeight; this.cv.width = this.w; this.cv.height = this.h; },
            shake() { this.shakeAmount = 8; },
            loop() {
                this.ctx.clearRect(0, 0, this.w, this.h);
                let sx = 0, sy = 0; if (this.shakeAmount > 0.1) { sx = (Math.random() - 0.5) * this.shakeAmount; sy = (Math.random() - 0.5) * this.shakeAmount; this.shakeAmount *= 0.9; }
                this.ctx.fillStyle = '#c2b280';
                this.particles.forEach(p => { p.x += p.vx; if (p.x > this.w) p.x = -5; this.ctx.beginPath(); this.ctx.arc(p.x + sx, p.y + sy, p.s, 0, Math.PI * 2); this.ctx.fill(); });
                requestAnimationFrame(() => this.loop());
            }
        };

        const PresetGallery = {
            show() {
                const overlay = document.createElement('div');
                overlay.className = 'preset-gallery';
                overlay.innerHTML = `
            <div class="gallery-close">×</div>
            <div class="gallery-controls">
                <button class="gallery-btn" id="modal-import-file">LOAD FILE</button>
                <button class="gallery-btn" id="modal-import-text">PASTE CODE</button>
                <button class="gallery-btn" id="modal-export">EXPORT FILE</button>
                <button class="gallery-btn" id="modal-help" style="border-color:#888; color:#888;">HELP</button>
            </div>
            
            <div class="gallery-paste-view" style="display:none;">
                <textarea class="gallery-paste-area" placeholder="Paste your JSON code here..."></textarea>
                <button class="gallery-btn" id="confirm-paste" style="width:100%">LOAD DATA</button>
            </div>

            <div class="gallery-grid">
                ${State.presetNames.map((name, i) => `
                    <div class="preset-thumb" data-slot="${i}">
                        <canvas width="200" height="150"></canvas>
                        <div class="preset-label">${name}</div>
                    </div>
                `).join('')}
            </div>
        `;
                overlay.querySelectorAll('canvas').forEach((cv, i) => {
                    const ctx = cv.getContext('2d');
                    const tracks = State.slots[i].tracks;
                    const colors = ['#ff8e72', '#ffdd44', '#aabbee', '#fff'];
                    tracks.forEach((track, tIdx) => {
                        const y = tIdx * 37.5;
                        track.forEach((step, sIdx) => {
                            step.forEach((note, rIdx) => {
                                if (note) {
                                    ctx.fillStyle = colors[tIdx];
                                    ctx.fillRect(sIdx * 12.5, y + rIdx * 6, 10, 4);
                                }
                            });
                        });
                    });
                });

                const gridView = overlay.querySelector('.gallery-grid');
                const pasteView = overlay.querySelector('.gallery-paste-view');

                overlay.querySelector('#modal-import-file').onclick = () => { State.importData(); overlay.remove(); };

                // Toggle Paste View
                overlay.querySelector('#modal-import-text').onclick = () => {
                    gridView.style.display = 'none';
                    pasteView.style.display = 'flex';
                };

                // Confirm Paste Logic
                overlay.querySelector('#confirm-paste').onclick = () => {
                    const text = overlay.querySelector('.gallery-paste-area').value;
                    if (text) {
                        State.importFromText(text);
                        overlay.remove();
                    }
                };

                overlay.querySelector('#modal-export').onclick = () => { State.exportData(); };
                overlay.querySelector('#modal-help').onclick = () => { overlay.remove(); Tutorial.show(); };
                overlay.querySelector('.gallery-close').onclick = () => overlay.remove();

                overlay.querySelectorAll('.preset-thumb').forEach(thumb => {
                    thumb.onclick = () => {
                        const idx = parseInt(thumb.dataset.slot);
                        State.slotA = idx;
                        App.updateFromState();
                        overlay.remove();
                        Toast("LOADED " + State.presetNames[idx]);
                    };
                });
                document.body.appendChild(overlay);
            }
        };

        class Rack {
            constructor(id, type, index, parent) {
                this.id = id; this.type = type; this.index = index;
                this.grid = Array(16).fill().map(() => Array(6).fill(false));
                this.intensity = 0.7; this.echo = 0.3; this.visualStep = -1;
                this.muted = false; this.waveformData = new Uint8Array(128);
                this.el = document.createElement('div'); this.el.className = 'rack'; this.el.dataset.type = type;
                this.updateDOM(); parent.appendChild(this.el);
                this.cv = this.el.querySelector('canvas'); this.ctx = this.cv.getContext('2d');
                this.resize(); this.bindEvents();
                setTimeout(() => { this.updateFaderUI('vol'); this.updateFaderUI('echo'); }, 100);

                // DRAG AND DROP
                this.el.addEventListener('dragover', (e) => { e.preventDefault(); this.el.classList.add('drag-over'); });
                this.el.addEventListener('dragleave', (e) => { e.preventDefault(); this.el.classList.remove('drag-over'); });
                this.el.addEventListener('drop', (e) => {
                    e.preventDefault();
                    this.el.classList.remove('drag-over');
                    const file = e.dataTransfer.files[0];
                    if (file) {
                        if (!Audio.ctx) Audio.init();
                        const reader = new FileReader();
                        reader.onload = (ev) => {
                            Audio.ctx.decodeAudioData(ev.target.result, (buffer) => {
                                Audio.buffers[this.type] = buffer;
                                console.log(`[KOPE] Drag-drop loaded ${this.type}: ${buffer.duration.toFixed(2)}s`);
                                Toast("SAMPLE LOADED");
                                Haptics.thud();
                                // RESET TRIM
                                Audio.trackConfig[this.type] = { start: 0, end: 1 };
                                this.updateLabel();
                                this.updateDOM();
                                // FIX: Restore canvas refs after DOM rebuild
                                this.cv = this.el.querySelector('canvas');
                                this.ctx = this.cv.getContext('2d');
                                this.resize();
                                this.bindEvents();
                            }, (err) => {
                                console.error(`[KOPE] Drag-drop decode error:`, err);
                                Toast("DECODE ERROR");
                            });
                        };
                        reader.readAsArrayBuffer(file);
                    }
                });
            }

            getSoundName() {
                const idx = State.slots[State.activeSlotIndex].sounds[this.index];
                const baseName = InstrumentConfigs[this.type][idx].name;
                // Show preset name + sample indicator if sample loaded
                if (Audio.buffers[this.type]) {
                    return baseName + " +SMP";
                }
                return baseName;
            }

            updateDOM() {
                let colorVar = `var(--c-${this.type})`;
                const hasSample = !!Audio.buffers[this.type];
                const extraBtn = hasSample ? `<div class="ctrl-btn-cut" title="Edit Sample">EDIT</div>` : '';

                this.el.innerHTML = `
            <div class="ctrl-col left">
                <div class="ctrl-btn-rec" title="Record">●</div>
                ${extraBtn}
                <div class="fader-wrap vol-fader"><div class="fader-track"></div><div class="fader-fill"></div><div class="fader-cap"></div></div>
                <div class="fader-lbl" id="lbl-left">VOL</div>
            </div>
            <div class="screen">
                <canvas></canvas>
                <div class="track-meta" id="tm-${this.index}" style="color:${colorVar}">
                    ${this.type.toUpperCase()} <span style="color:#888; font-size:9px">// ${this.getSoundName()}</span>
                </div>
            </div>
            <div class="ctrl-col right">
                <div class="ctrl-btn-std clear-btn">X</div>
                <div class="fader-wrap echo-fader"><div class="fader-track"></div><div class="fader-fill echo"></div><div class="fader-cap echo"></div></div>
                <div class="fader-lbl" id="lbl-right">ECHO</div>
            </div>
        `;

                // Track Name Click Logic
                const tm = this.el.querySelector('.track-meta');
                let pressTimer;
                let downTime;

                tm.onpointerdown = (e) => {
                    e.preventDefault();
                    downTime = Date.now();
                    tm.classList.add('ready-to-load');

                    pressTimer = setTimeout(() => {
                        Toast("RELEASE TO LOAD FILE");
                    }, 500);

                    const upHandler = () => {
                        tm.classList.remove('ready-to-load');
                        clearTimeout(pressTimer);

                        // If held long enough (>= 500ms) -> Load Sample
                        if (Date.now() - downTime >= 500) {
                            State.loadSampleForTrack(this.type);
                        }
                        // Short Click -> Cycle Sounds OR open editor if sample loaded
                        else {
                            if (Audio.buffers[this.type]) {
                                // Sample loaded: open editor so user can USE SYNTH or edit trim
                                SampleEditor.open(this.type);
                            } else {
                                // No sample: cycle synth sounds
                                const currentSounds = State.slots[State.activeSlotIndex].sounds;
                                currentSounds[this.index] = (currentSounds[this.index] + 1) % 3;
                                this.updateLabel();
                                State.saveToStorage();
                                Toast(State.sets[currentSounds[this.index]]);
                            }
                        }
                        tm.removeEventListener('pointerup', upHandler);
                    };
                    tm.addEventListener('pointerup', upHandler);
                };

                const recBtn = this.el.querySelector('.ctrl-btn-rec');
                recBtn.onpointerdown = (e) => {
                    e.preventDefault();
                    recBtn.classList.add('recording');
                    Audio.record(this.type);
                    setTimeout(() => recBtn.classList.remove('recording'), 1500);
                };

                if (hasSample) {
                    const cutBtn = this.el.querySelector('.ctrl-btn-cut');
                    cutBtn.onpointerdown = (e) => {
                        e.preventDefault();
                        Haptics.click();
                        console.log(`[KOPE] Opening editor for ${this.type}`);
                        SampleEditor.open(this.type);
                    };
                }
            }

            updateLabel() {
                const el = document.getElementById(`tm-${this.index}`);
                if (el) el.innerHTML = `${this.type.toUpperCase()} <span style="color:#888; font-size:9px">// ${this.getSoundName()}</span>`;
            }

            resize() { const r = this.el.querySelector('.screen').getBoundingClientRect(); this.w = r.width; this.h = r.height; this.cv.width = this.w; this.cv.height = this.h; }

            updateFaderUI(type) {
                const wrap = type === 'vol' ? this.el.querySelector('.vol-fader') : this.el.querySelector('.echo-fader');
                if (!wrap) return;
                const cap = wrap.querySelector('.fader-cap'); const fill = wrap.querySelector('.fader-fill');
                const val = type === 'vol' ? this.intensity : this.echo;
                cap.style.bottom = `${val * 100}%`; fill.style.height = `${val * 100}%`;
            }

            bindEvents() {
                const faders = this.el.querySelectorAll('.fader-wrap');
                faders.forEach(el => { el.style.touchAction = "none"; });

                const bindFader = (selector, param) => {
                    const el = this.el.querySelector(selector);
                    const handler = (y) => {
                        const r = el.getBoundingClientRect();
                        let val = 1 - ((y - r.top) / r.height);
                        val = Math.max(0, Math.min(1, val));
                        this[param] = val;
                        this.updateFaderUI(param === 'intensity' ? 'vol' : 'echo');
                    };
                    el.addEventListener('pointerdown', e => {
                        e.preventDefault(); handler(e.clientY); el.setPointerCapture(e.pointerId);
                        el.onpointermove = (ev) => handler(ev.clientY);
                        el.onpointerup = () => { el.onpointermove = null; };
                    });
                };
                bindFader('.vol-fader', 'intensity'); bindFader('.echo-fader', 'echo');

                this.el.querySelector('.clear-btn').onpointerdown = (e) => {
                    e.preventDefault(); this.grid.forEach(c => c.fill(false));
                    State.slots[State.activeSlotIndex].tracks[this.index] = Array(16).fill().map(() => Array(6).fill(false));
                    Toast(`CLEARED ${this.id}`);
                };

                const input = (x, y) => {
                    if (!this.w || !this.h) this.resize();
                    const c = Math.floor((x / this.w) * 16);
                    const r = Math.floor((y / this.h) * 6);
                    if (c >= 0 && c < 16 && r >= 0 && r < 6) {
                        this.grid[c][r] = !this.grid[c][r];
                        State.slots[State.activeSlotIndex].tracks[this.index][c][r] = this.grid[c][r];
                        console.log(`[KOPE] Toggle ${this.type} step:${c} row:${r} -> ${this.grid[c][r]}`);
                    }
                };

                // Ensure canvas has touch-action set
                this.cv.style.touchAction = 'none';

                this.cv.onpointerdown = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    // Capture pointer for reliable mobile handling
                    if (e.pointerId !== undefined) {
                        try { this.cv.setPointerCapture(e.pointerId); } catch (err) { }
                    }
                    const rect = this.cv.getBoundingClientRect();
                    input(e.clientX - rect.left, e.clientY - rect.top);
                };
            }

            trigger(step, time, slotA, slotB, morph) {
                if (this.muted) return;
                const inA = State.slots[slotA].tracks[this.index][step];
                const inB = State.slots[slotB].tracks[this.index][step];
                const sndA = State.slots[slotA].sounds[this.index];
                const sndB = State.slots[slotB].sounds[this.index];

                for (let r = 0; r < 6; r++) {
                    if (inA[r]) {
                        let volA = 1.0;
                        if (inB[r]) volA = 1.0;
                        else volA = Math.cos(morph * 0.5 * Math.PI);

                        if (volA > 0.05) this.playNote(r, time, volA, sndA, this.type);
                    }

                    if (inB[r]) {
                        let volB = Math.sin(morph * 0.5 * Math.PI);
                        if (inA[r]) volB = 0;

                        if (volB > 0.05) this.playNote(r, time, volB, sndB, this.type);
                    }
                }
            }

            playNote(r, time, volMod, soundIdx, type) {
                const freq = CONFIG.root * Math.pow(2, (CONFIG.scale[13 - r * 2] || 0) / 12);
                const finalVol = this.intensity * volMod;

                // Pass Row Index 'r' for sample pitch shifting
                if (type === 'rhythm') Synths.play(Audio.ctx, 'rhythm', freq, time, finalVol, InstrumentConfigs.rhythm[soundIdx].type, r);
                else if (type === 'lead') Synths.play(Audio.ctx, 'lead', freq * 2, time, finalVol, InstrumentConfigs.lead[soundIdx].type, r);
                else if (type === 'swell') Synths.play(Audio.ctx, 'swell', freq, time, finalVol, InstrumentConfigs.swell[soundIdx].type, r);
                else Synths.perc(Audio.ctx, r, time, finalVol, InstrumentConfigs.perc[soundIdx].mod);
            }

            draw(slotA, slotB, morph) {
                const c = this.ctx;
                c.fillStyle = '#000'; c.fillRect(0, 0, this.w, this.h);
                const cellW = this.w / 16; const rowH = this.h / 6;

                // Draw Waveform background if sample present
                if (Audio.buffers[this.type] && this.w) {
                    c.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    // visualize trim area
                    const cfg = Audio.trackConfig[this.type];
                    const startX = cfg.start * this.w;
                    const endX = cfg.end * this.w;

                    // Draw active region
                    const typeColor = this.type === 'rhythm' ? '#ff8e72' : this.type === 'lead' ? '#ffdd44' : '#aabbee';
                    c.fillStyle = typeColor;
                    c.globalAlpha = 0.2;
                    c.fillRect(startX, 0, Math.max(1, endX - startX), this.h);
                    c.globalAlpha = 1.0;
                }

                if (this.visualStep > -1) {
                    c.fillStyle = 'rgba(255,183,0,0.1)'; c.fillRect(this.visualStep * cellW, 0, cellW, this.h);
                }

                // Waveform Animation (Synth)
                if (Audio.ctx && !this.muted && Audio[this.type].analyzer) {
                    Audio[this.type].analyzer.getByteTimeDomainData(this.waveformData);
                    c.strokeStyle = 'rgba(255,183,0,0.2)'; c.lineWidth = 2; c.beginPath();
                    const slice = this.w / 128;
                    for (let i = 0; i < 128; i++) {
                        const v = this.waveformData[i] / 128.0; const y = v * this.h / 2;
                        i === 0 ? c.moveTo(0, y) : c.lineTo(i * slice, y);
                    }
                    c.stroke();
                }

                c.lineWidth = 1;
                for (let r = 0; r < 6; r++) {
                    c.strokeStyle = '#333'; c.beginPath();
                    const y = (r + 0.5) * rowH; c.moveTo(0, y); c.lineTo(this.w, y); c.stroke();

                    for (let s = 0; s < 16; s++) {
                        const inA = State.slots[slotA].tracks[this.index][s][r];
                        const inB = State.slots[slotB].tracks[this.index][s][r];

                        let color, opacity = 0;
                        if (inA && inB) { color = '255,255,255'; opacity = 1.0; }
                        else if (inA) { color = '255,183,0'; opacity = 1.0 - morph; }
                        else if (inB) { color = '68,136,255'; opacity = morph; }

                        // FORCE WHITE VISIBILITY if sample loaded
                        if (Audio.buffers[this.type] && (inA || inB)) {
                            color = '255,255,255';
                            opacity = 0.9;
                        }

                        if (opacity > 0.1) {
                            c.fillStyle = `rgba(${color},${opacity})`;
                            c.beginPath(); c.arc(s * cellW + cellW / 2, y, 4, 0, Math.PI * 2); c.fill();
                        }
                    }
                }
            }
        }

        /* TUTORIAL OVERLAY */
        const Tutorial = {
            STORAGE_KEY: 'el_desierto_tutorial_v1',

            hasSeenTutorial() {
                return localStorage.getItem(this.STORAGE_KEY) === 'true';
            },

            markSeen() {
                localStorage.setItem(this.STORAGE_KEY, 'true');
            },

            show() {
                const overlay = document.createElement('div');
                overlay.className = 'tutorial-overlay';
                overlay.innerHTML = `
                    <div class="tutorial-content">
                        <div class="tutorial-title">WELCOME TO EL DESIERTO</div>
                        <div class="tutorial-steps">
                            <div class="tutorial-step">
                                <span class="tutorial-step-icon">1</span>
                                <div><strong>Add Notes:</strong> Tap the grid to toggle notes on/off</div>
                            </div>
                            <div class="tutorial-step">
                                <span class="tutorial-step-icon">2</span>
                                <div><strong>Mix:</strong> Drag faders for volume and echo</div>
                            </div>
                            <div class="tutorial-step">
                                <span class="tutorial-step-icon">3</span>
                                <div><strong>Load Sample:</strong> Long-press any track name</div>
                            </div>
                            <div class="tutorial-step">
                                <span class="tutorial-step-icon">4</span>
                                <div><strong>Edit Sample:</strong> Click EDIT to trim, pitch-shift, slow down</div>
                            </div>
                            <div class="tutorial-step">
                                <span class="tutorial-step-icon">5</span>
                                <div><strong>Morph:</strong> Slide between two patterns at the bottom</div>
                            </div>
                        </div>
                        <button class="tutorial-dismiss">START JAMMING</button>
                        <span class="tutorial-skip">Don't show again</span>
                    </div>
                `;
                document.body.appendChild(overlay);

                overlay.querySelector('.tutorial-dismiss').onclick = () => {
                    this.markSeen();
                    overlay.remove();
                };

                overlay.querySelector('.tutorial-skip').onclick = () => {
                    this.markSeen();
                    overlay.remove();
                };
            }
        };

        const App = {
            racks: [],
            lastTickVal: 0,
            init() {
                State.init(); Sand.init();
                const cont = $('rack-container');
                this.racks.push(new Rack(0, 'rhythm', 0, cont));
                this.racks.push(new Rack(1, 'lead', 1, cont));
                this.racks.push(new Rack(2, 'swell', 2, cont));
                this.racks.push(new Rack(3, 'perc', 3, cont));

                App.updateFromState();

                const start = () => {
                    Audio.init();
                    if (Audio.ctx) Audio.ctx.resume();
                    Synths.powerUp(Audio.ctx);
                    $('unlock').remove();
                    // Show tutorial on first launch
                    if (!Tutorial.hasSeenTutorial()) {
                        setTimeout(() => Tutorial.show(), 300);
                    }
                };
                $('btn-start').onclick = start;
                $('fab-mini').onclick = () => Audio.toggle();

                $('btn-set').onclick = () => {
                    const currentSlot = State.slots[State.activeSlotIndex];
                    const nextSetIdx = (currentSlot.sounds[0] + 1) % 3;
                    currentSlot.sounds = [nextSetIdx, nextSetIdx, nextSetIdx, nextSetIdx];
                    $('btn-set').innerText = "SET: " + State.sets[nextSetIdx];
                    Toast(`SLOT ${State.presetNames[State.activeSlotIndex]} -> ${State.sets[nextSetIdx]}`);
                    App.racks.forEach(r => r.updateLabel());
                    State.saveToStorage();
                };

                const bpmEl = $('bpm-slider');
                const updateBpm = (x) => {
                    const r = bpmEl.getBoundingClientRect();
                    let val = Math.max(0, Math.min(1, (x - r.left) / r.width));
                    const bpm = Math.floor(60 + val * 100);
                    CONFIG.bpm = bpm; $('bpm-display').innerText = bpm;
                    State.slots[State.activeSlotIndex].bpm = bpm;
                    bpmEl.querySelector('.fader-fill').style.width = (val * 100) + '%';
                    bpmEl.querySelector('.fader-cap').style.left = (val * 100) + '%';
                    if (Math.floor(bpm / 10) !== this.lastBpmTick) { Haptics.tick(); this.lastBpmTick = Math.floor(bpm / 10); }
                    State.saveToStorage();
                };
                bpmEl.onpointerdown = e => { e.preventDefault(); updateBpm(e.clientX); bpmEl.onpointermove = ev => updateBpm(ev.clientX); bpmEl.setPointerCapture(e.pointerId); };
                bpmEl.onpointerup = () => bpmEl.onpointermove = null;

                const morphEl = $('morph-track');
                const updateMorph = (x) => {
                    const r = morphEl.getBoundingClientRect();
                    let val = Math.max(0, Math.min(1, (x - r.left) / r.width));
                    State.morph = val;
                    $('morph-thumb').style.left = (val * 100) + '%';
                    $('morph-fill').style.width = (val * 100) + '%';

                    if (val > 0.5) {
                        $('slot-b-btn').classList.add('active-edit-b');
                        $('slot-a-btn').classList.remove('active-edit-a');
                    } else {
                        $('slot-a-btn').classList.add('active-edit-a');
                        $('slot-b-btn').classList.remove('active-edit-b');
                    }

                    if (Math.abs(val - 0.5) < 0.05 && !this.snappedCenter) { Haptics.thud(); this.snappedCenter = true; }
                    if (Math.abs(val - 0.5) > 0.1) this.snappedCenter = false;

                    App.updateFromState();
                };
                morphEl.onpointerdown = e => { e.preventDefault(); updateMorph(e.clientX); morphEl.onpointermove = ev => updateMorph(ev.clientX); morphEl.setPointerCapture(e.pointerId); };
                morphEl.onpointerup = () => morphEl.onpointermove = null;

                const bindSlotSelector = (el, type) => {
                    el.onpointerdown = (e) => {
                        e.preventDefault();
                        let timer = setTimeout(() => {
                            const idx = type === 'A' ? State.slotA : State.slotB;
                            State.saveSlot(idx);
                        }, 800);

                        el.onpointerup = () => {
                            clearTimeout(timer);
                            if (type === 'A') {
                                State.slotA = (State.slotA + 1) % 4;
                                if (State.slotA === State.slotB) State.slotA = (State.slotA + 1) % 4;
                            } else {
                                State.slotB = (State.slotB + 1) % 4;
                                if (State.slotB === State.slotA) State.slotB = (State.slotB + 1) % 4;
                            }
                            App.updateFromState();
                        };
                    };
                };
                bindSlotSelector($('slot-a-btn'), 'A');
                bindSlotSelector($('slot-b-btn'), 'B');

                $('btn-help').onclick = () => PresetGallery.show();

                setTimeout(() => this.racks.forEach(r => r.resize()), 100);
                window.addEventListener('resize', () => this.racks.forEach(r => r.resize()));
                this.loop();
            },

            updateFromState() {
                $('slot-a-btn').childNodes[0].nodeValue = State.presetNames[State.slotA];
                $('slot-b-btn').childNodes[0].nodeValue = State.presetNames[State.slotB];
                $('label-a').innerText = "SLOT " + State.presetNames[State.slotA];
                $('label-b').innerText = "SLOT " + State.presetNames[State.slotB];

                const activeIdx = State.activeSlotIndex;
                const titleEl = $('app-title');
                titleEl.classList.add('changing');
                setTimeout(() => { titleEl.innerText = State.presetNames[activeIdx]; titleEl.classList.remove('changing'); }, 200);

                const slotData = State.slots[activeIdx];
                const setIdx = slotData.sounds[0];
                $('btn-set').innerText = "SET: " + State.sets[setIdx];

                App.racks.forEach(r => r.updateLabel());

                const bpmVal = (slotData.bpm - 60) / 100;
                const bpmEl = $('bpm-slider');
                bpmEl.querySelector('.fader-fill').style.width = (bpmVal * 100) + '%';
                bpmEl.querySelector('.fader-cap').style.left = (bpmVal * 100) + '%';
                $('bpm-display').innerText = slotData.bpm;
                CONFIG.bpm = slotData.bpm;

                if (State.morph > 0.5) {
                    $('slot-b-btn').classList.add('active-edit-b');
                    $('slot-a-btn').classList.remove('active-edit-a');
                } else {
                    $('slot-a-btn').classList.add('active-edit-a');
                    $('slot-b-btn').classList.remove('active-edit-b');
                }
            },

            updateTrackLabel(trackId, text) {
                const rack = this.racks.find(r => r.type === trackId);
                if (rack) {
                    const el = document.getElementById(`tm-${rack.index}`);
                    if (el) el.innerHTML = `${rack.type.toUpperCase()} <span style="color:#888; font-size:9px">// ${text}</span>`;
                    rack.updateDOM();
                    // FIX: Restore canvas refs after DOM rebuild
                    rack.cv = rack.el.querySelector('canvas');
                    rack.ctx = rack.cv.getContext('2d');
                    rack.resize();
                    rack.bindEvents();
                    console.log(`[KOPE] Track label updated: ${trackId} -> ${text}`);
                }
            },

            refreshTrackUI(trackId) {
                const rack = this.racks.find(r => r.type === trackId);
                if (rack) {
                    rack.updateDOM();
                    // FIX: Restore canvas refs after DOM rebuild
                    rack.cv = rack.el.querySelector('canvas');
                    rack.ctx = rack.cv.getContext('2d');
                    rack.resize();
                    rack.bindEvents();
                    console.log(`[KOPE] Refreshed track UI: ${trackId}, canvas restored`);
                }
            },

            loop() {
                this.racks.forEach(r => r.draw(State.slotA, State.slotB, State.morph));
                requestAnimationFrame(() => this.loop());
            }
        };

        Audio.doStep = (s, t) => {
            App.racks.forEach(r => {
                r.visualStep = s;
                r.trigger(s, t, State.slotA, State.slotB, State.morph);
            });
        };

        window.onload = () => App.init();
    </script>
</body>

</html>
